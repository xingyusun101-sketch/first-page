<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æ‰‹åŠ¿è¯†åˆ«ç²’å­ç³»ç»Ÿ</title>

  <!-- MediaPipe ä¾èµ– -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #0a0a1e;
      font-family: Arial, sans-serif;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #video {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 150px;
      border: 2px solid #4a90e2;
      border-radius: 8px;
      transform: scaleX(-1);
      z-index: 10;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      padding: 12px 14px;
      border-radius: 10px;
      color: #fff;
      z-index: 10;
      max-width: 270px;
      max-height: calc(100vh - 20px);
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
    #controls::-webkit-scrollbar {
      width: 6px;
    }
    
    #controls::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 3px;
    }
    
    #controls::-webkit-scrollbar-thumb {
      background: rgba(74, 144, 226, 0.5);
      border-radius: 3px;
    }
    
    #controls::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 144, 226, 0.7);
    }

    #controls h3 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      margin-bottom: 8px;
      color: #4a90e2;
    }

    #controlsToggle {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid #4a90e2;
      background: rgba(0, 0, 0, 0.6);
      color: #4a90e2;
      cursor: pointer;
      white-space: nowrap;
    }

    #controlsToggle:hover {
      background: rgba(74, 144, 226, 0.15);
    }

    #controls.collapsed {
      padding: 6px 10px;
      max-width: 190px;
      overflow: visible;
    }

    #controls.collapsed h3 {
      margin-bottom: 0;
      font-size: 13px;
    }

    #controls.collapsed #controlsContent {
      display: none;
    }

    .control-group {
      margin-bottom: 12px;
    }

    .control-group label {
      display: block;
      font-size: 12px;
      margin-bottom: 5px;
      color: #aaa;
    }

    .control-group input[type="range"] {
      width: 100%;
    }

    .status {
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .status.waiting {
      background: rgba(255, 165, 0, 0.2);
      border: 1px solid orange;
    }

    .status.ready {
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid lime;
    }

    .gesture-info {
      background: rgba(100, 100, 255, 0.2);
      padding: 8px;
      border-radius: 5px;
      font-size: 11px;
      margin-top: 10px;
      line-height: 1.5;
    }

    h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #4a90e2;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <video id="video" autoplay playsinline></video>

    <div id="controls">
      <h3>
        ğŸ® æ‰‹åŠ¿æ§åˆ¶ç²’å­ç³»ç»Ÿ
        <button id="controlsToggle" type="button">æ”¶èµ·é¢æ¿</button>
      </h3>

      <div id="controlsContent">
      <div id="status" class="status waiting">
        æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...
      </div>

        <div id="speedIndicator" style="font-size: 10px; color: #888; margin-bottom: 10px; display: none;">
          ç§»åŠ¨é€Ÿåº¦: <span id="speedValue">0</span>
      </div>

      <div class="control-group">
        <label>
          ç²’å­æ•°é‡:
            <span id="particleCountValue">600</span>
        </label>
        <input
          type="range"
          id="particleCount"
            min="200"
            max="1200"
            value="600"
        />
      </div>

      <div class="control-group">
        <label>
          äº¤äº’å¼ºåº¦:
          <span id="forceValue">1.0</span>
        </label>
        <input
          type="range"
          id="force"
          min="0.5"
          max="3"
          step="0.1"
          value="1.0"
        />
      </div>

        <div class="control-group">
          <label>
            <input type="checkbox" id="trailMode" checked />
            æ‹–å°¾æ•ˆæœ
          </label>
        </div>

        <div class="control-group">
          <label>
            <input type="checkbox" id="rainbowMode" />
            å½©è™¹æ¨¡å¼
          </label>
      </div>

      <div class="gesture-info">
        <strong>æ‰‹åŠ¿è¯´æ˜ï¼š</strong><br />
        âœ‹ å¼ å¼€æ‰‹æŒ - å¸å¼•ç²’å­<br />
        âœŠ æ¡ç´§æ‹³å¤´ - æ’æ–¥ç²’å­<br />
        â˜ï¸ ä¼¸å‡ºé£ŸæŒ‡ - å‘å°„ç²’å­<br />
          âœŒï¸ èƒœåˆ©æ‰‹åŠ¿ï¼ˆç­‰åŒäºæ¯”2ï¼‰ - ç²’å­çˆ†ç‚¸<br />
          â˜ï¸ æ¯” 1 æ‰‹åŠ¿ - æ‹¼æˆæ–‡å­—<br />
          4ï¸âƒ£ æ¯” 4 æ‰‹åŠ¿ - ä¸¤ä¸ªå°äººè·³èˆ<br />
          ğŸ‘Šâœ‹ å·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1 - ç²’å­æ±‡èšæˆæ—‹è½¬çƒä½“<br />
          <br />
          <strong>åŒæ‰‹ç»„åˆæ‰‹åŠ¿ï¼š</strong><br />
          ğŸ‘ˆ1 + ğŸ‘‰1 = ğŸŒªï¸ æ—‹é£ç”Ÿæˆ<br />
          ğŸ‘ˆ1 + ğŸ‘‰2 = ğŸ’¨ ç²’å­å¹æ•£<br />
          ğŸ‘ˆ1 + ğŸ‘‰4 = ğŸŒ€ æ°”æµæŠ˜å°„<br />
          ğŸ‘ˆ1 + ğŸ‘‰5 = â›ˆï¸ æš´é£æ¨¡å¼<br />
          <br />
          <strong>ç«ç³»ç²’å­æ§åˆ¶ï¼ˆå·¦æ‰‹2ï¼‰ï¼š</strong><br />
          ğŸ‘ˆ2 + ğŸ‘‰1 = ğŸ”¥ ç«çƒå‡èš<br />
          ğŸ‘ˆ2 + ğŸ‘‰2 = ğŸ”¥ ç«ç„°å–·å°„<br />
          ğŸ‘ˆ2 + ğŸ‘‰4 = ğŸ’¥ ç«ç„°çˆ†è£‚<br />
          ğŸ‘ˆ2 + ğŸ‘‰5 = ğŸ”¥ ç«ç„°å‡¤å‡°<br />
          <br />
          <strong>ç©ºé—´æ‰­æ›²æ§åˆ¶ï¼ˆå·¦æ‰‹4ï¼‰ï¼š</strong><br />
          ğŸ‘ˆ4 + ğŸ‘‰1 = ğŸ•³ï¸ è™«æ´å¸å¼•<br />
          ğŸ‘ˆ4 + ğŸ‘‰4 = â„ï¸ ç²’å­å†»ç»“<br />
          ğŸ‘ˆ4 + ğŸ‘‰5 = âª æ—¶é—´å€’æµ<br />
          <br />
          <strong>æ°´ç³»ç²’å­æ§åˆ¶ï¼ˆå³æ‰‹2ï¼‰ï¼š</strong><br />
          ğŸ‘ˆ3 + ğŸ‘‰2 = ğŸŒ§ï¸ é›¨æ»´ç”Ÿæˆ<br />
          ğŸ‘ˆ4 + ğŸ‘‰2 = ğŸ’§ ç²’å­å‡ç»“<br />
          ğŸ‘ˆ5 + ğŸ‘‰2 = ğŸŒŠ æ°´æµåˆ†è£‚<br />
          <br />
          <strong>é«˜çº§ç»„åˆæ•ˆæœï¼š</strong><br />
          ğŸ‘‰1 + ğŸ‘ˆ5 = ğŸŒ  é‡åŠ›æ‰­æ›²ç¯<br />
          ğŸ‘‰2 + ğŸ‘ˆ5 = ğŸ’§ é‡åŠ›æ°´å¼§<br />
          ğŸ‘‰2 + ğŸ‘ˆ4 = ğŸŒªï¸ æ—¶ç©ºèºæ—‹æªï¼ˆå³æ‰‹2ï¼Œå·¦æ‰‹4ï¼‰<br />
          ğŸ‘‰4 + ğŸ‘ˆ1 = âš¡ é›·æš´å¼•å¯¼<br />
          ğŸ‘‰4 + ğŸ‘ˆ5 = ğŸŒˆ é›¶é‡åŠ›å½©è‰²å¼§çº¿<br />
          ğŸ‘‰5 + ğŸ‘ˆ5 = âš¡ åŒæ‰‹é›·ç”µçƒ<br />
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');
    const statusDiv = document.getElementById('status');
    const controls = document.getElementById('controls');
    const controlsContent = document.getElementById('controlsContent');
    const controlsToggle = document.getElementById('controlsToggle');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [];
    let handData = null; // å•åªæ‰‹æ•°æ®ï¼ˆç”¨äºå…¼å®¹ï¼‰
    let handsData = []; // å¤šåªæ‰‹æ•°æ®æ•°ç»„
    let previousHandData = null;
    let previousHandsData = []; // å¤šåªæ‰‹å†å²æ•°æ®
    let isHandsClosing = false; // åŒæ‰‹æ˜¯å¦åœ¨åˆæ‹¢
    let previousHandsDistance = Infinity; // ä¸Šä¸€å¸§åŒæ‰‹è·ç¦»
    let handsClosingStartTime = 0; // å¼€å§‹åˆæ‹¢çš„æ—¶é—´
    let sphereCenterX = 0; // çƒä½“ä¸­å¿ƒX
    let sphereCenterY = 0; // çƒä½“ä¸­å¿ƒY
    let sphereRadius = 0; // çƒä½“åŠå¾„
    let particleCount = 600;
    let forceMultiplier = 1.0;
    let trailMode = true;
    let rainbowMode = false;
    let rainbowHue = 0;
    let explosions = [];
    let previousPalmX = 0;
    let previousPalmY = 0;
    let handSpeed = 0;
    let textTargets = []; // æ–‡å­—ç›®æ ‡ä½ç½®
    let isFormingText = false; // æ˜¯å¦æ­£åœ¨å½¢æˆæ–‡å­—
    let windEffectType = null; // å½“å‰é£ç³»æ•ˆæœç±»å‹ï¼ˆ'tornado', 'blow', 'flow', 'distortion', 'storm'ï¼‰
    let tornadoCenterX = 0; // æ—‹é£ä¸­å¿ƒX
    let tornadoCenterY = 0; // æ—‹é£ä¸­å¿ƒY
    let tornadoRotation = 0; // æ—‹é£æ—‹è½¬è§’åº¦
    let windDirection = { x: 0, y: 0 }; // é£å‘
    let stormActive = false; // æš´é£æ¨¡å¼æ˜¯å¦æ¿€æ´»
    let stormStartTime = 0; // æš´é£å¼€å§‹æ—¶é—´
    let flowLines = []; // æµçº¿ç²’å­æ•°ç»„
    let distortionWaves = []; // æŠ˜å°„æ³¢çº¹æ•°ç»„
    
    // ç«ç³»æ•ˆæœå˜é‡
    let fireEffectType = null; // å½“å‰ç«ç³»æ•ˆæœç±»å‹ï¼ˆ'fireball', 'flame', 'lava', 'explosion', 'phoenix'ï¼‰
    let fireballCenterX = 0; // ç«çƒä¸­å¿ƒX
    let fireballCenterY = 0; // ç«çƒä¸­å¿ƒY
    let fireballIntensity = 0; // ç«çƒå¼ºåº¦ï¼ˆåŸºäºåŒæ‰‹è·ç¦»ï¼‰
    let previousRightHandGesture = null; // ä¸Šä¸€å¸§å³æ‰‹æ‰‹åŠ¿ï¼ˆç”¨äºæ£€æµ‹æ”¶æ‹³â†’å¼ å¼€ï¼‰
    let explosionActive = false; // çˆ†ç‚¸æ˜¯å¦æ¿€æ´»
    let explosionStartTime = 0; // çˆ†ç‚¸å¼€å§‹æ—¶é—´
    let phoenixTrail = []; // å‡¤å‡°å°¾è¿¹æ•°ç»„
    let phoenixPosition = { x: 0, y: 0 }; // å‡¤å‡°ä½ç½®
    
    // æ°´ç³»æ•ˆæœå˜é‡
    let waterEffectType = null; // å½“å‰æ°´ç³»æ•ˆæœç±»å‹ï¼ˆ'ripple', 'rain', 'condense', 'split'ï¼‰
    let rippleCenterX = 0; // æ¶Ÿæ¼ªä¸­å¿ƒX
    let rippleCenterY = 0; // æ¶Ÿæ¼ªä¸­å¿ƒY
    let rippleWaves = []; // æ¶Ÿæ¼ªæ³¢æ•°ç»„ {x, y, radius, time, amplitude}
    let rainParticles = []; // é›¨æ»´ç²’å­æ•°ç»„ {x, y, vx, vy, size, life}
    let condenseThreshold = 30; // ç²’å­å‡ç»“è·ç¦»é˜ˆå€¼
    let splitStreamCenterX = 0; // æ°´æµåˆ†è£‚ä¸­å¿ƒX
    let splitStreamCenterY = 0; // æ°´æµåˆ†è£‚ä¸­å¿ƒY
    let splitStreamAngle = 0; // æ°´æµåˆ†è£‚è§’åº¦
    let previousRippleTime = 0; // ä¸Šæ¬¡ç”Ÿæˆæ¶Ÿæ¼ªçš„æ—¶é—´
    
    // é«˜çº§ç»„åˆæ•ˆæœå˜é‡
    let advancedEffectType = null; // å½“å‰é«˜çº§ç»„åˆæ•ˆæœç±»å‹
    let serpentChain1 = []; // ç¬¬ä¸€æ¡è›‡å½¢é“¾ç²’å­æ•°ç»„
    let serpentChain2 = []; // ç¬¬äºŒæ¡è›‡å½¢é“¾ç²’å­æ•°ç»„
    let spaceTearPath = []; // ç©ºé—´è£‚ç¼è·¯å¾„
    let spaceTearActive = false; // ç©ºé—´è£‚ç¼æ˜¯å¦æ¿€æ´»
    let gravityRingCenterX = 0; // é‡åŠ›ç¯ä¸­å¿ƒX
    let gravityRingCenterY = 0; // é‡åŠ›ç¯ä¸­å¿ƒY
    let gravityRingRadius = 0; // é‡åŠ›ç¯åŠå¾„
    let gravityRingAngle = 0; // é‡åŠ›ç¯è§’åº¦
    let flameJetStartX = 0; // ç«ç„°å–·å°„èµ·ç‚¹X
    let flameJetStartY = 0; // ç«ç„°å–·å°„èµ·ç‚¹Y
    let flameJetDirection = { x: 0, y: 0 }; // ç«ç„°å–·å°„æ–¹å‘
    let spiralBeamCenterX = 0; // èºæ—‹æŸä¸­å¿ƒX
    let spiralBeamCenterY = 0; // èºæ—‹æŸä¸­å¿ƒY
    let spiralBeamRotation = 0; // èºæ—‹æŸæ—‹è½¬è§’åº¦
    let gravityArcGravity = { x: 0, y: 0 }; // é‡åŠ›æ–¹å‘
    let stormClouds = []; // é›·äº‘æ•°ç»„
    let lightningActive = false; // é—ªç”µæ˜¯å¦æ¿€æ´»
    let plasmaArcStartX = 0; // ç­‰ç¦»å­å¼§èµ·ç‚¹X
    let plasmaArcStartY = 0; // ç­‰ç¦»å­å¼§èµ·ç‚¹Y
    let plasmaArcEndX = 0; // ç­‰ç¦»å­å¼§ç»ˆç‚¹X
    let plasmaArcEndY = 0; // ç­‰ç¦»å­å¼§ç»ˆç‚¹Y
    let rainbowCurlParticles = []; // å½©è™¹å¼§çº¿ç²’å­
    let starDustCenterX = 0; // æ˜Ÿå°˜ä¸­å¿ƒX
    let starDustCenterY = 0; // æ˜Ÿå°˜ä¸­å¿ƒY
    let starDustRotation = 0; // æ˜Ÿå°˜æ—‹è½¬è§’åº¦
    let infernoBlackHoleX = 0; // ç«ä¹‹é»‘æ´ä¸­å¿ƒX
    let infernoBlackHoleY = 0; // ç«ä¹‹é»‘æ´ä¸­å¿ƒY
    let infernoBlackHoleIntensity = 0; // ç«ä¹‹é»‘æ´å¼ºåº¦
    let spatialBladeStartX = 0; // ç©ºé—´ä¹‹åˆƒèµ·ç‚¹X
    let spatialBladeStartY = 0; // ç©ºé—´ä¹‹åˆƒèµ·ç‚¹Y
    let spatialBladeEndX = 0; // ç©ºé—´ä¹‹åˆƒç»ˆç‚¹X
    let spatialBladeEndY = 0; // ç©ºé—´ä¹‹åˆƒç»ˆç‚¹Y
    let lightningBoltActive = false; // é—ªç”µæ˜¯å¦æ¿€æ´»
    let lightningBoltTime = 0; // é—ªç”µæ—¶é—´æˆ³
    let lightningBoltStartX = 0; // é—ªç”µèµ·ç‚¹Xï¼ˆå·¦æ‰‹ï¼‰
    let lightningBoltStartY = 0; // é—ªç”µèµ·ç‚¹Yï¼ˆå·¦æ‰‹ï¼‰
    let lightningBoltEndX = 0; // é—ªç”µç»ˆç‚¹Xï¼ˆå³æ‰‹ï¼‰
    let lightningBoltEndY = 0; // é—ªç”µç»ˆç‚¹Yï¼ˆå³æ‰‹ï¼‰
    let lightningBoltPath = []; // é—ªç”µè·¯å¾„ç‚¹æ•°ç»„
    
    // ç©ºé—´æ‰­æ›²æ•ˆæœå˜é‡
    let spaceEffectType = null; // å½“å‰ç©ºé—´æ‰­æ›²æ•ˆæœç±»å‹ï¼ˆ'blackhole', 'portal', 'freeze', 'rewind'ï¼‰
    let blackHoleX = 0; // è™«æ´ä¸­å¿ƒX
    let blackHoleY = 0; // è™«æ´ä¸­å¿ƒY
    let blackHoleIntensity = 0; // è™«æ´å¼ºåº¦ï¼ˆåŸºäºæ‰‹çš„é«˜åº¦ï¼‰
    let portalCenterX = 0; // ä¼ é€é—¨ä¸­å¿ƒX
    let portalCenterY = 0; // ä¼ é€é—¨ä¸­å¿ƒY
    let portalRadius = 0; // ä¼ é€é—¨åŠå¾„
    let portalRotation = 0; // ä¼ é€é—¨æ—‹è½¬è§’åº¦
    let particlesFrozen = false; // ç²’å­æ˜¯å¦è¢«å†»ç»“
    let particleHistory = []; // ç²’å­å†å²è½¨è¿¹ï¼ˆç”¨äºæ—¶é—´å€’æµï¼‰
    let rewindActive = false; // æ—¶é—´å€’æµæ˜¯å¦æ¿€æ´»
    let previousRightHandPosition = { x: 0, y: 0 }; // ä¸Šä¸€å¸§å³æ‰‹ä½ç½®ï¼ˆç”¨äºæ£€æµ‹æ—‹è½¬ï¼‰
    let rightHandRotationAngle = 0; // å³æ‰‹æ—‹è½¬è§’åº¦
    
    // æ°´ç³»æ•ˆæœå˜é‡å·²åœ¨ä¸Šé¢å£°æ˜ï¼ˆç¬¬311-320è¡Œï¼‰ï¼Œè¿™é‡Œä¸å†é‡å¤å£°æ˜
    // ä¿ç•™å…¶ä»–å¯èƒ½éœ€è¦çš„å˜é‡ï¼ˆå¦‚æœä»£ç ä¸­ä»åœ¨ä½¿ç”¨ï¼‰
    let heightMapSize = 50; // é«˜åº¦å›¾ç½‘æ ¼å¤§å°ï¼ˆå¦‚æœä»åœ¨ä½¿ç”¨ï¼‰
    let heightMapVelocity = []; // é«˜åº¦å›¾é€Ÿåº¦ï¼ˆå¦‚æœä»åœ¨ä½¿ç”¨ï¼‰
    let isSphereMode = false; // æ˜¯å¦å¤„äºç«‹ä½“çƒæ¨¡å¼
    let sphereRotation = 0; // çƒä½“æ—‹è½¬è§’åº¦
    let danceTargets = []; // è·³èˆå°äººç›®æ ‡ä½ç½®
    let isDancing = false; // æ˜¯å¦æ­£åœ¨è·³èˆ
    let danceFrame = 0; // è·³èˆåŠ¨ç”»å¸§æ•°
    let meteorFrame = 0; // æµæ˜ŸåŠ¨ç”»å¸§æ•°
    let gestureHistory = []; // æ‰‹åŠ¿å†å²è®°å½•ï¼ˆç”¨äºç¨³å®šè¯†åˆ«ï¼‰
    const GESTURE_HISTORY_SIZE = 5; // æ‰‹åŠ¿å†å²è®°å½•å¤§å°

    // ç®€å•åˆ¤æ–­æ˜¯å¦ä¸ºæ‰‹æœºè®¾å¤‡ï¼Œç”¨äºåšä¸€äº›è‡ªé€‚åº”è°ƒæ•´
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // çˆ†ç‚¸æ•ˆæœç±»
    class Explosion {
      constructor(x, y, color, intensity = 1) {
        this.x = x;
        this.y = y;
        this.particles = [];
        this.color = color;
        // intensityå‚æ•°ï¼š1=æ™®é€šçˆ†ç‚¸ï¼Œ2=å¼ºçƒˆçˆ†ç‚¸ï¼ˆç”¨äºçƒä½“çˆ†ç‚¸ï¼‰
        const particleCount = intensity === 2 ? 80 : 20;
        const speedMultiplier = intensity === 2 ? 20 : 10;
        const lifeDecay = intensity === 2 ? 0.01 : 0.02;
        
        for (let i = 0; i < particleCount; i++) {
          const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
          const speed = (Math.random() * 0.5 + 0.5) * speedMultiplier;
          this.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed + (Math.random() - 0.5) * 3,
            vy: Math.sin(angle) * speed + (Math.random() - 0.5) * 3,
            life: 1,
            lifeDecay: lifeDecay,
            size: Math.random() * (intensity === 2 ? 6 : 4) + (intensity === 2 ? 3 : 2),
          });
        }
      }

      update() {
        this.particles = this.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.life -= p.lifeDecay;
          return p.life > 0;
        });
        return this.particles.length > 0;
      }

      draw() {
        this.particles.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.globalAlpha = p.life;
          ctx.fill();
          ctx.globalAlpha = 1;
        });
      }
    }

    // ç²’å­ç±»
    class Particle {
      constructor() {
        this.reset();
        this.trail = [];
        this.maxTrailLength = 8;
        this.life = 1;
        this.maxLife = 1;
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.size = Math.random() * 2 + 0.8; // å‡å°ç²’å­å¤§å°ï¼Œè®©æ›´å¤šç²’å­å¯è§
        this.hue = Math.random() * 60 + 180;
        this.trail = [];
        this.life = 1;
        this.maxLife = 1;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.targetX = null; // ç›®æ ‡Xä½ç½®ï¼ˆç”¨äºæ–‡å­—å½¢æˆï¼‰
        this.targetY = null; // ç›®æ ‡Yä½ç½®ï¼ˆç”¨äºæ–‡å­—å½¢æˆï¼‰
        this.targetIndex = null; // ç›®æ ‡ç´¢å¼•ï¼ˆç”¨äºè·³èˆåŠ¨ç”»ï¼‰
        this.sphereLat = null; // çƒä½“æ¨¡å¼ï¼šçº¬åº¦
        this.sphereLon = null; // çƒä½“æ¨¡å¼ï¼šç»åº¦
      }

      update() {
        // ä½¿ç”¨å…¨å±€çš„ handsData æ•°ç»„ï¼Œæ”¯æŒå¤šåªæ‰‹
        // è®°å½•è½¨è¿¹
        if (trailMode) {
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
          }
        }

        // å¦‚æœå¤„äºç«‹ä½“çƒæ¨¡å¼ï¼ˆåŒæ‰‹åˆæ‹¢ï¼‰ï¼Œä¼˜å…ˆæ²¿çƒä½“è½¨é“è¿åŠ¨
        if (isSphereMode && this.sphereLat !== null && this.sphereLon !== null) {
          // çƒä½“ä¸­å¿ƒå›ºå®šåœ¨å±å¹•ä¸­å¿ƒ
          const cx = sphereCenterX || canvas.width / 2;
          const cy = sphereCenterY || canvas.height / 2;
          // ä½¿ç”¨åŠ¨æ€è®¡ç®—çš„çƒä½“åŠå¾„
          const radius = sphereRadius || Math.min(canvas.width, canvas.height) * 0.25;

          // 3D çƒåæ ‡
          const lat = this.sphereLat;
          const lon = this.sphereLon + sphereRotation;

          const x3 = Math.cos(lat) * Math.cos(lon);
          const y3 = Math.sin(lat);
          const z3 = Math.cos(lat) * Math.sin(lon);

          // ç®€å•é€è§†ç¼©æ”¾ï¼ˆz è¶Šå¤§è¶Šé å‰ï¼‰
          const depth = (z3 + 1) / 2; // 0~1
          const scale = 0.3 + depth * 0.7;

          const targetX = cx + x3 * radius * scale * 1.2;
          const targetY = cy + y3 * radius * scale * 1.2;

          const dxSphere = targetX - this.x;
          const dySphere = targetY - this.y;
          const distSphere = Math.sqrt(dxSphere * dxSphere + dySphere * dySphere);

          const sphereForce = Math.min(0.25, distSphere / 100) * 0.25;
          this.vx += dxSphere * sphereForce;
          this.vy += dySphere * sphereForce;

          this.vx *= 0.9;
          this.vy *= 0.9;

          this.x += this.vx;
          this.y += this.vy;

          // çƒä½“æ¨¡å¼ä¸‹çš„é¢œè‰²ï¼šæ¨¡æ‹Ÿåœ°çƒè“ç»¿è‰²
          const baseHue = 200 + depth * 40; // 200~240
          this.hue = rainbowMode ? (rainbowHue + depth * 60) % 360 : baseHue;
          this.size = 1.5 + depth * 2; // å‰æ™¯ç²’å­æ›´å¤§

          return;
        }

        // è¾¹ç•Œåå¼¹
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

        this.x = Math.max(0, Math.min(canvas.width, this.x));
        this.y = Math.max(0, Math.min(canvas.height, this.y));

        // æ‰‹åŠ¿å½±å“ï¼ˆè·³èˆæ¨¡å¼å’ŒåŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹å¿½ç•¥ï¼Œé¿å…å¹²æ‰°ï¼‰
        // æ”¯æŒå¤šåªæ‰‹ï¼Œç²’å­åŒæ—¶å—åˆ°æ‰€æœ‰æ‰‹çš„å½±å“
        // ç¡®ä¿ handsData å­˜åœ¨ä¸”æ˜¯æ•°ç»„
        const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        // åœ¨åŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹ï¼Œç¦ç”¨æ‰‹åŠ¿æ•ˆæœï¼Œè®©ç²’å­ä¸“æ³¨äºå½¢æˆçƒä½“
        // å¦‚æœä»»ä½•åŒ hand æ•ˆæœï¼ˆæ°´ç³»ã€é£ç³»ã€ç«ç³»ã€ç©ºé—´ã€é«˜çº§ç»„åˆï¼‰æ¿€æ´»ï¼Œä¹Ÿç¦ç”¨å•æ‰‹çš„å¸å¼•æ•ˆæœ
        const shouldApplyGesture = !isDancing && !isHandsClosing && !waterEffectType && !windEffectType && !fireEffectType && !spaceEffectType && !advancedEffectType;
        if (shouldApplyGesture && currentHandsData.length > 0) {
          // éå†æ‰€æœ‰æ‰‹ï¼Œè®¡ç®—æ¯åªæ‰‹å¯¹ç²’å­çš„å½±å“
          for (let handIdx = 0; handIdx < currentHandsData.length; handIdx++) {
            const hands = currentHandsData[handIdx];
          const palmX = hands.palmX * canvas.width;
          const palmY = hands.palmY * canvas.height;
          const dx = palmX - this.x;
          const dy = palmY - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
            const radius = 400 + handSpeed * 80; // æ‰©å¤§å½±å“èŒƒå›´ï¼Œé€Ÿåº¦å½±å“èŒƒå›´

          if (dist < radius) {
              const force = ((radius - dist) / radius) * forceMultiplier * (1 + handSpeed * 0.5);
            const angle = Math.atan2(dy, dx);

              // æ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´ç²’å­å¤§å°ï¼ˆä½¿ç”¨æœ€è¿‘çš„æ‰‹ï¼‰
              if (handIdx === 0 || dist < Math.sqrt(
                Math.pow(currentHandsData[0].palmX * canvas.width - this.x, 2) +
                Math.pow(currentHandsData[0].palmY * canvas.height - this.y, 2)
              )) {
                this.size = Math.max(0.8, Math.min(4, 1.5 + (radius - dist) / radius * 2.5));
              }

            if (hands.gesture === 'open' || hands.gesture === 'five') {
                // å¼ å¼€æ‰‹æŒ - å¸å¼•ï¼ˆå¢å¼ºæ•ˆæœï¼‰
                const attractForce = force * (1.2 + (radius - dist) / radius * 0.8); // è·ç¦»è¶Šè¿‘å¸å¼•åŠ›è¶Šå¼º
                this.vx += Math.cos(angle) * attractForce;
                this.vy += Math.sin(angle) * attractForce;
                this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 280;
            } else if (hands.gesture === 'closed') {
                // æ¡æ‹³ - æ’æ–¥ï¼ˆæ ¹æ®è·ç¦»è¡°å‡ï¼Œé¿å…è¿œè·ç¦»ç²’å­ä¹±è·‘ï¼‰
                // æ’æ–¥åŠ›åº”è¯¥éšç€è·ç¦»å¢åŠ è€Œå‡å¼±ï¼Œåªåœ¨è¿‘è·ç¦»æ—¶å¼ºçƒˆæ’æ–¥
                const distanceFactor = Math.max(0, 1.0 - dist / radius); // è·ç¦»å› å­ï¼šè·ç¦»è¶Šè¿œï¼Œå› å­è¶Šå°
                const repelForce = force * distanceFactor * distanceFactor * 0.5; // é™ä½æ’æ–¥åŠ›å¼ºåº¦ï¼Œä½¿ç”¨å¹³æ–¹è¡°å‡
                this.vx -= Math.cos(angle) * repelForce;
                this.vy -= Math.sin(angle) * repelForce;
                
                // é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼Œé˜²æ­¢ç²’å­ä¹±è·‘ï¼ˆæ›´ä¸¥æ ¼çš„é€Ÿåº¦é™åˆ¶ï¼‰
                const maxSpeed = 12; // é™ä½æœ€å¤§é€Ÿåº¦é™åˆ¶
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > maxSpeed) {
                  const scale = maxSpeed / currentSpeed;
                  this.vx *= scale;
                  this.vy *= scale;
                }
                
                this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 0;
            } else if (hands.gesture === 'pointing') {
              // é£ŸæŒ‡ - å‘å°„
              this.vx -= Math.cos(angle) * force * 2;
              this.vy -= Math.sin(angle) * force * 2;
                this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 30;
              } else if (hands.gesture === 'two') {
                // æ¯”2æ‰‹åŠ¿ï¼ˆåŒ…æ‹¬èƒœåˆ©æ‰‹åŠ¿ï¼‰- çˆ†ç‚¸æ•ˆæœ + è·Ÿéšæ‰‹æŒ‡
                const explosionForce = force * 3;
                this.vx += (Math.random() - 0.5) * explosionForce;
                this.vy += (Math.random() - 0.5) * explosionForce;
                
                // è·Ÿéšé£ŸæŒ‡å’Œä¸­æŒ‡
                if (hands.landmarks && hands.landmarks[8] && hands.landmarks[12]) {
                  const indexX = hands.landmarks[8].x * canvas.width;
                  const indexY = hands.landmarks[8].y * canvas.height;
                  const middleX = hands.landmarks[12].x * canvas.width;
                  const middleY = hands.landmarks[12].y * canvas.height;
                  const avgX = (indexX + middleX) / 2;
                  const avgY = (indexY + middleY) / 2;
                  
                  const followDx = avgX - this.x;
                  const followDy = avgY - this.y;
                  const followDist = Math.sqrt(followDx * followDx + followDy * followDy);
                  
                  if (followDist < 150) {
                    this.vx += followDx * 0.02;
                    this.vy += followDy * 0.02;
                  }
                }
                
                this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : (dist * 2) % 360;
              }
            }
          }
        }

        // æ¯” 4 æ‰‹åŠ¿å½¢æˆè·³èˆå°äººæ—¶ï¼Œå¼ºåˆ¶ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆç›®æ ‡ä½ç½®ä¼šæŒç»­æ›´æ–°å®ç°åŠ¨ç”»ï¼‰
        // åŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹ç¦ç”¨è·³èˆæ•ˆæœ
        if (isDancing && !isHandsClosing) {
          if (this.targetIndex !== null && this.targetIndex < danceTargets.length) {
            // è·³èˆæ—¶ç›®æ ‡ä½ç½®ä¼šæŒç»­å˜åŒ–ï¼Œä½¿ç”¨ä¿å­˜çš„ç´¢å¼•æ›´æ–°ç›®æ ‡
            this.targetX = danceTargets[this.targetIndex].x;
            this.targetY = danceTargets[this.targetIndex].y;
            
            const targetDx = this.targetX - this.x;
            const targetDy = this.targetY - this.y;
            const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
            
            if (targetDist > 2) {
              // å¼ºå¸å¼•åŠ›ï¼Œè®©ç²’å­å¿«é€Ÿç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
              const danceForce = Math.min(0.3, targetDist / 100) * 0.3;
              this.vx += targetDx * danceForce;
              this.vy += targetDy * danceForce;
              this.vx *= 0.9; // å¢åŠ é˜»å°¼
              this.vy *= 0.9;
              
              // æ›´æ–°é¢œè‰²å’Œå¤§å°ï¼ˆè·³èˆå°äººç”¨æ©™é»„è‰²ç³»ï¼‰
              this.hue = rainbowMode ? (rainbowHue + targetDist * 2) % 360 : 40;
              this.size = Math.max(1.8, Math.min(3.5, 2.5 + (100 - targetDist) / 100 * 1));
            } else {
              // å·²ç»åˆ°è¾¾ç›®æ ‡ä½ç½®
              this.x = this.targetX;
              this.y = this.targetY;
              this.vx *= 0.7;
              this.vy *= 0.7;
              this.hue = rainbowMode ? rainbowHue % 360 : 40;
              this.size = 2.5;
            }
          } else {
            // æ²¡æœ‰å‚ä¸è·³èˆçš„ç²’å­ï¼Œå½¢æˆæµæ˜Ÿåˆ’è¿‡æ•ˆæœ
            // è®¡ç®—å°äººåŒºåŸŸçš„ä¸­å¿ƒä½ç½®å’Œä¸Šæ–¹åŒºåŸŸ
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 + Math.min(canvas.width, canvas.height) * (isMobile ? 0.15 : 0.2) * 0.8;
            const meteorAreaTop = centerY - Math.min(canvas.width, canvas.height) * 0.4; // å°äººä¸Šæ–¹åŒºåŸŸ
            const meteorAreaWidth = canvas.width * 0.9; // æµæ˜ŸåŒºåŸŸå®½åº¦
            
            // ä¸ºæ¯ä¸ªç²’å­åˆ†é…ä¸€ä¸ªå›ºå®šçš„IDï¼ˆåŸºäºç²’å­ç´¢å¼•ï¼‰ï¼Œå½¢æˆä¸åŒçš„æµæ˜Ÿè½¨è¿¹
            const particleId = particles.indexOf(this);
            const meteorOffset = (particleId % 200) / 200; // 0-1ä¹‹é—´çš„åç§»ï¼Œç”¨äºé”™å¼€æµæ˜Ÿæ—¶é—´
            const meteorProgress = ((meteorFrame * 0.5 + meteorOffset * 200) % 300) / 300; // æµæ˜Ÿè¿›åº¦ 0-1
            
            // æµæ˜Ÿèµ·å§‹ä½ç½®ï¼ˆåœ¨å°äººä¸Šæ–¹ï¼Œå·¦å³åˆ†å¸ƒï¼‰
            const meteorStartX = centerX - meteorAreaWidth / 2 + (particleId % 80) / 80 * meteorAreaWidth;
            const meteorEndX = meteorStartX + (Math.random() - 0.5) * 50; // ç»ˆç‚¹ç¨å¾®åç§»
            
            // æµæ˜Ÿè½¨è¿¹ï¼šä»ä¸Šå¾€ä¸‹åˆ’è¿‡
            const meteorY = meteorAreaTop - 100 + meteorProgress * (canvas.height - meteorAreaTop + 150);
            const meteorX = meteorStartX + (meteorEndX - meteorStartX) * meteorProgress;
            
            // è®¡ç®—å½“å‰ä½ç½®åˆ°æµæ˜Ÿè½¨è¿¹çš„å¸å¼•åŠ›
            const dx = meteorX - this.x;
            const dy = meteorY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // å‘æµæ˜Ÿè½¨è¿¹ç§»åŠ¨
            const meteorForce = Math.min(0.2, dist / 150) * 0.25;
            this.vx += dx * meteorForce;
            this.vy += dy * meteorForce;
            this.vx *= 0.9;
            this.vy *= 0.9;
            
            // æµæ˜Ÿé¢œè‰²ï¼ˆè“ç™½è‰²ç³»ï¼Œæ ¹æ®è¿›åº¦å˜åŒ–ï¼‰
            const brightness = 1 - meteorProgress * 0.3; // è¶Šå¾€ä¸‹è¶Šæš—
            this.hue = rainbowMode ? (rainbowHue + dist * 1.5) % 360 : 200;
            this.size = Math.max(1.5, Math.min(3, 2.5 * brightness));
            
            // å¦‚æœç²’å­è¶…å‡ºå±å¹•ä¸‹æ–¹ï¼Œé‡ç½®åˆ°ä¸Šæ–¹ï¼ˆå½¢æˆå¾ªç¯ï¼‰
            if (this.y > canvas.height + 50) {
              this.y = meteorAreaTop - 100;
              this.x = centerX - meteorAreaWidth / 2 + Math.random() * meteorAreaWidth;
              this.vx = (Math.random() - 0.5) * 1;
              this.vy = Math.random() * 1 + 2;
            }
          }
        }

        // é£ç³»æ•ˆæœå¤„ç†ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        if (windEffectType && !isHandsClosing) {
          const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          
          if (windEffectType === 'tornado' && currentHandsData.length >= 2) {
            // å·¦1å³1 - æ—‹é£ç”Ÿæˆï¼šåœ¨æ‰‹å¿ƒå¤„ç”Ÿæˆæ—‹è½¬ç²’å­æ¼©æ¶¡ï¼Œéšå³æ‰‹ç§»åŠ¨å¸å…¥é™„è¿‘ç²’å­
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              tornadoCenterX = rightHand.palmX * canvas.width;
              tornadoCenterY = rightHand.palmY * canvas.height;
              tornadoRotation += 0.2; // åŠ å¿«æ—‹è½¬é€Ÿåº¦
              
              const dx = tornadoCenterX - this.x;
              const dy = tornadoCenterY - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const maxRadius = 250; // æ‰©å¤§å½±å“èŒƒå›´
              
              if (dist < maxRadius) {
                // é¾™å·é£å½¢çŠ¶ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„ï¼ˆé”¥å½¢ï¼‰
                // è®¡ç®—ç²’å­ç›¸å¯¹äºä¸­å¿ƒçš„å‚ç›´ä½ç½®ï¼ˆå‡è®¾åº•éƒ¨åœ¨canvasåº•éƒ¨ï¼‰
                const bottomY = canvas.height;
                const topY = tornadoCenterY - 300; // é¾™å·é£é¡¶éƒ¨ï¼ˆæ›´é«˜ï¼‰
                const tornadoHeight = bottomY - topY;
                const particleHeight = this.y - topY;
                const heightRatio = Math.max(0, Math.min(1, particleHeight / tornadoHeight));
                
                // æ ¹æ®é«˜åº¦è®¡ç®—é¾™å·é£åŠå¾„ï¼ˆåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„ï¼‰
                const baseRadius = maxRadius * 0.9; // åº•éƒ¨åŠå¾„ï¼ˆæ›´å®½ï¼‰
                const topRadius = maxRadius * 0.1; // é¡¶éƒ¨åŠå¾„ï¼ˆæ›´çª„ï¼‰
                const tornadoRadius = baseRadius * (1 - heightRatio) + topRadius * heightRatio;
                
                // è®¡ç®—ç²’å­åˆ°é¾™å·é£ä¸­å¿ƒè½´çš„è·ç¦»ï¼ˆè€ƒè™‘é”¥å½¢ï¼‰
                const angle = Math.atan2(dy, dx);
                const radialDist = dist;
                
                // å¦‚æœç²’å­åœ¨é¾™å·é£èŒƒå›´å†…
                if (radialDist < tornadoRadius * 1.3 && this.y >= topY && this.y <= bottomY) {
                  // å¼ºçƒˆçš„æ—‹è½¬åŠ›ï¼šç²’å­å›´ç»•ä¸­å¿ƒå¿«é€Ÿæ—‹è½¬
                  const rotationSpeed = 0.4 + (1 - heightRatio) * 0.5; // åº•éƒ¨æ—‹è½¬æ›´å¿«
                  const rotationAngle = angle + tornadoRotation * rotationSpeed;
                  const rotationForce = (1 - radialDist / tornadoRadius) * 3.0; // å¤§å¹…å¢å¼ºæ—‹è½¬åŠ›
                  this.vx += Math.cos(rotationAngle) * rotationForce;
                  this.vy += Math.sin(rotationAngle) * rotationForce;
                  
                  // å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å…¥é¾™å·é£ä¸­å¿ƒ
                  const pullForce = (1 - radialDist / tornadoRadius) * 2.2; // å¤§å¹…å¢å¼ºå‘å¿ƒåŠ›
                  if (radialDist > 0) {
                    this.vx += (dx / radialDist) * pullForce;
                    this.vy += (dy / radialDist) * pullForce;
                  }
                  
                  // ä¸Šå‡åŠ›ï¼šç²’å­å‘ä¸Šç§»åŠ¨ï¼ˆå½¢æˆé¾™å·é£ä¸Šå‡æ°”æµï¼‰
                  const upwardForce = (1 - heightRatio) * 1.5; // åº•éƒ¨ä¸Šå‡åŠ›æ›´å¼º
                  this.vy -= upwardForce;
                  
                  // èºæ—‹æ•ˆæœï¼šæ·»åŠ èºæ—‹ä¸Šå‡è¿åŠ¨
                  const spiralAngle = angle + tornadoRotation * 2.5 + heightRatio * Math.PI * 3;
                  const spiralForce = (1 - radialDist / tornadoRadius) * 1.0;
                  this.vx += Math.cos(spiralAngle) * spiralForce;
                  this.vy += Math.sin(spiralAngle) * spiralForce - 0.6; // å‘ä¸Šåç§»
                  
                  // é¢œè‰²ï¼šæ ¹æ®é«˜åº¦å’Œæ—‹è½¬è§’åº¦å˜åŒ–ï¼ˆç°è‰²åˆ°ç™½è‰²ï¼Œæ¨¡æ‹Ÿé¾™å·é£ï¼‰
                  const tornadoIntensity = (1 - radialDist / tornadoRadius) * (1 - heightRatio * 0.4);
                  this.hue = rainbowMode ? (rainbowHue + tornadoRotation * 57.3) % 360 : 200 + tornadoIntensity * 40;
                  this.size = Math.max(2.5, Math.min(7, 3 + tornadoIntensity * 4)); // å¢å¤§ç²’å­å°ºå¯¸
                }
              }
            }
          } else if (windEffectType === 'blow' && currentHandsData.length >= 2) {
            // å·¦1å³2 - ç²’å­å¹æ•£ï¼šæœå³æ‰‹æ–¹å‘äº§ç”Ÿå¼ºé£ï¼Œç²’å­è¢«å¹æˆæ•£å°„æ•ˆæœ
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              const dx = this.x - handX;
              const dy = this.y - handY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 200;
              
              if (dist < radius) {
                // è®¡ç®—é£å‘ï¼ˆä»å·¦æ‰‹åˆ°å³æ‰‹ï¼‰
                const leftHand = currentHandsData.find(h => h.handedness === 'Left') || currentHandsData[0];
                if (leftHand) {
                  const leftX = leftHand.palmX * canvas.width;
                  const leftY = leftHand.palmY * canvas.height;
                  const windDx = handX - leftX;
                  const windDy = handY - leftY;
                  const windDist = Math.sqrt(windDx * windDx + windDy * windDy);
                  
                  if (windDist > 0) {
                    const windForce = (1 - dist / radius) * 1.5;
                    this.vx += (windDx / windDist) * windForce;
                    this.vy += (windDy / windDist) * windForce;
                    
                    // æ·»åŠ æ•£å°„æ•ˆæœï¼ˆéšæœºåç§»ï¼‰
                    this.vx += (Math.random() - 0.5) * 0.5;
                    this.vy += (Math.random() - 0.5) * 0.5;
                    
                    this.hue = rainbowMode ? (rainbowHue + dist * 0.4) % 360 : 200;
                    this.size = Math.max(1.2, Math.min(3.5, 1.8 + (radius - dist) / radius * 1.7));
                  }
                }
              }
            }
          } else if (windEffectType === 'distortion' && currentHandsData.length >= 2) {
            // å·¦1å³4 - æ°”æµæŠ˜å°„ï¼šæ‰‹ç§»åŠ¨æ—¶åœ¨ç©ºæ°”ä¸­åˆ¶é€ "æ‰­æ›²ç‰¹æ•ˆ"ï¼Œç²’å­äº§ç”ŸæŠ˜å°„æ³¢çº¹
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              const dx = this.x - handX;
              const dy = this.y - handY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 160;
              
              if (dist < radius) {
                // æ³¢çº¹æ•ˆæœï¼šäº§ç”ŸåŒå¿ƒåœ†æ³¢çº¹
                const wavePhase = dist * 0.1 - Date.now() * 0.01;
                const waveAmplitude = (1 - dist / radius) * 0.8;
                const waveX = Math.cos(wavePhase) * waveAmplitude;
                const waveY = Math.sin(wavePhase) * waveAmplitude;
                
                // æŠ˜å°„æ•ˆæœï¼šç²’å­ä½ç½®äº§ç”Ÿæ‰­æ›²
                const angle = Math.atan2(dy, dx);
                this.vx += Math.cos(angle + wavePhase) * waveAmplitude * 0.5;
                this.vy += Math.sin(angle + wavePhase) * waveAmplitude * 0.5;
                
                // æ·»åŠ æ—‹è½¬æ‰­æ›²
                const twistAngle = angle + wavePhase * 2;
                this.vx += Math.cos(twistAngle) * waveAmplitude * 0.3;
                this.vy += Math.sin(twistAngle) * waveAmplitude * 0.3;
                
                this.hue = rainbowMode ? (rainbowHue + wavePhase * 57.3) % 360 : 210;
                this.size = Math.max(1.3, Math.min(3.5, 2 + Math.abs(waveAmplitude) * 1.5));
              }
            }
          } else if (windEffectType === 'storm') {
            // å·¦1å³5 - æš´é£æ¨¡å¼ï¼šçŸ­æš‚çˆ†å‘çš„å…¨å±ç²’å­é£æš´ï¼Œä¼´éšæ—‹è½¬æ–¹å‘ç®­å¤´
            if (!stormActive) {
              stormActive = true;
              stormStartTime = Date.now();
            }
            
            const stormDuration = 2000; // 2ç§’
            const elapsed = Date.now() - stormStartTime;
            const progress = Math.min(1, elapsed / stormDuration);
            
            if (progress < 1) {
              // å…¨å±é£æš´æ•ˆæœ
              const stormIntensity = (1 - progress) * 2; // é€æ¸å‡å¼±
              
              // éšæœºé£å‘å’Œå¼ºåº¦
              const stormAngle = Date.now() * 0.005;
              const stormForce = stormIntensity * (0.8 + Math.random() * 0.4);
              
              this.vx += Math.cos(stormAngle) * stormForce;
              this.vy += Math.sin(stormAngle) * stormForce;
              
              // æ·»åŠ æ—‹è½¬æ•ˆæœ
              const centerX = canvas.width / 2;
              const centerY = canvas.height / 2;
              const dx = this.x - centerX;
              const dy = this.y - centerY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const rotationForce = stormIntensity * 0.3;
              const rotAngle = Math.atan2(dy, dx) + Math.PI / 2;
              this.vx += Math.cos(rotAngle) * rotationForce;
              this.vy += Math.sin(rotAngle) * rotationForce;
              
              this.hue = rainbowMode ? (rainbowHue + stormAngle * 57.3) % 360 : 200 + progress * 40;
              this.size = Math.max(1.5, Math.min(4, 2.5 + stormIntensity * 1.5));
            } else {
              // é£æš´ç»“æŸ
              stormActive = false;
              windEffectType = null;
            }
          }
        }
        
        // ç«ç³»æ•ˆæœå¤„ç†ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        if (fireEffectType && !isHandsClosing) {
          const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          
          if (fireEffectType === 'fireball' && currentHandsData.length >= 2) {
            // å·¦2å³1 - ç«çƒå‡èšï¼šåœ¨ä¸¤æ‰‹ä¹‹é—´å‡èšä¸€ä¸ªèƒ½é‡ç«çƒï¼Œè¶Šé è¿‘è¶Šäº®
            const leftHand = currentHandsData.find(h => h.handedness === 'Left') || currentHandsData[0];
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            
            if (leftHand && rightHand) {
              const leftX = leftHand.palmX * canvas.width;
              const leftY = leftHand.palmY * canvas.height;
              const rightX = rightHand.palmX * canvas.width;
              const rightY = rightHand.palmY * canvas.height;
              
              // è®¡ç®—ä¸¤æ‰‹ä¸­å¿ƒç‚¹
              fireballCenterX = (leftX + rightX) / 2;
              fireballCenterY = (leftY + rightY) / 2;
              
              // è®¡ç®—ä¸¤æ‰‹è·ç¦»ï¼Œè·ç¦»è¶Šè¿‘ç«çƒè¶Šäº®
              const handsDistance = Math.sqrt(Math.pow(rightX - leftX, 2) + Math.pow(rightY - leftY, 2));
              fireballIntensity = Math.max(0, 1 - handsDistance / 1000); // å½’ä¸€åŒ–åˆ°0-1ï¼Œå½±å“èŒƒå›´0-1000åƒç´ 
              
              const dx = fireballCenterX - this.x;
              const dy = fireballCenterY - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 200 + fireballIntensity * 150; // å¢åŠ ç«çƒåŠå¾„å’Œå½±å“èŒƒå›´
              
              if (dist < radius) {
                // å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å…¥ç«çƒä¸­å¿ƒï¼ˆå¢å¼ºåŠ›åº¦ï¼‰
                const pullForce = (1 - dist / radius) * fireballIntensity * 1.5; // å¢å¼ºå¸å¼•åŠ›
                if (dist > 0) {
                  this.vx += (dx / dist) * pullForce;
                  this.vy += (dy / dist) * pullForce;
                }
                
                // æ—‹è½¬æ•ˆæœï¼šç²’å­å›´ç»•ç«çƒæ—‹è½¬ï¼ˆå¢å¼ºæ—‹è½¬ï¼‰
                const rotationAngle = Math.atan2(dy, dx) + Date.now() * 0.008; // åŠ å¿«æ—‹è½¬
                const rotationForce = (1 - dist / radius) * fireballIntensity * 0.8; // å¢å¼ºæ—‹è½¬åŠ›
                this.vx += Math.cos(rotationAngle) * rotationForce;
                this.vy += Math.sin(rotationAngle) * rotationForce;
                
                // é¢œè‰²ï¼šç«çº¢è‰²ç³»ï¼Œè¶Šé è¿‘è¶Šäº®ï¼ˆæ©™è‰²åˆ°é»„è‰²åˆ°ç™½è‰²ï¼‰
                const brightness = fireballIntensity * (1 - dist / radius);
                this.hue = rainbowMode ? (rainbowHue + dist * 0.3) % 360 : 10 + brightness * 50; // 10-60 (æ·±çº¢åˆ°é»„åˆ°ç™½)
                this.size = Math.max(2.5, Math.min(6, 3 + brightness * 3)); // å¢å¤§ç²’å­å°ºå¯¸
              }
            }
          } else if (fireEffectType === 'flame' && currentHandsData.length >= 2) {
            // å·¦2å³2 - ç«ç„°å–·å°„ï¼šåŒæ‰‹éƒ½è¦ç«ç„°å–·å°„
            const leftHand = currentHandsData.find(h => h.handedness === 'Left') || currentHandsData[0];
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            
            // å¤„ç†å³æ‰‹ç«ç„°å–·å°„
            if (rightHand && rightHand.landmarks) {
              const indexTip = rightHand.landmarks[8];
              const indexTipX = indexTip.x * canvas.width;
              const indexTipY = indexTip.y * canvas.height;
              
              const middleTip = rightHand.landmarks[12];
              const middleTipX = middleTip.x * canvas.width;
              const middleTipY = middleTip.y * canvas.height;
              
              const flameDx = middleTipX - indexTipX;
              const flameDy = middleTipY - indexTipY;
              const flameDist = Math.sqrt(flameDx * flameDx + flameDy * flameDy);
              
              if (flameDist > 0) {
                const flameAngle = Math.atan2(flameDy, flameDx);
                const dx = this.x - indexTipX;
                const dy = this.y - indexTipY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angle - flameAngle);
                
                const sprayWidth = Math.min(100, flameDist * 3);
                const sprayLength = 350;
                
                if (dist < sprayLength && angleDiff < Math.PI / 2.5) {
                  const inSpray = dist * Math.sin(angleDiff) < sprayWidth;
                  if (inSpray) {
                    const force = (1 - dist / sprayLength) * (1 - angleDiff / (Math.PI / 2.5)) * 2.0;
                    this.vx += Math.cos(flameAngle) * force;
                    this.vy += Math.sin(flameAngle) * force;
                    
                    this.vx += (Math.random() - 0.5) * 0.6;
                    this.vy += (Math.random() - 0.5) * 0.6;
                    
                    const flameIntensity = (1 - dist / sprayLength) * (1 - angleDiff / (Math.PI / 2.5));
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 50) % 360 : 5 + flameIntensity * 55;
                    this.size = Math.max(2, Math.min(5, 3 + flameIntensity * 2));
                  }
                }
              }
            }
            
            // å¤„ç†å·¦æ‰‹ç«ç„°å–·å°„
            if (leftHand && leftHand.landmarks) {
              const indexTip = leftHand.landmarks[8];
              const indexTipX = indexTip.x * canvas.width;
              const indexTipY = indexTip.y * canvas.height;
              
              const middleTip = leftHand.landmarks[12];
              const middleTipX = middleTip.x * canvas.width;
              const middleTipY = middleTip.y * canvas.height;
              
              const flameDx = middleTipX - indexTipX;
              const flameDy = middleTipY - indexTipY;
              const flameDist = Math.sqrt(flameDx * flameDx + flameDy * flameDy);
              
              if (flameDist > 0) {
                const flameAngle = Math.atan2(flameDy, flameDx);
                const dx = this.x - indexTipX;
                const dy = this.y - indexTipY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angle - flameAngle);
                
                const sprayWidth = Math.min(100, flameDist * 3);
                const sprayLength = 350;
                
                if (dist < sprayLength && angleDiff < Math.PI / 2.5) {
                  const inSpray = dist * Math.sin(angleDiff) < sprayWidth;
                  if (inSpray) {
                    const force = (1 - dist / sprayLength) * (1 - angleDiff / (Math.PI / 2.5)) * 2.0;
                    this.vx += Math.cos(flameAngle) * force;
                    this.vy += Math.sin(flameAngle) * force;
                    
                    this.vx += (Math.random() - 0.5) * 0.6;
                    this.vy += (Math.random() - 0.5) * 0.6;
                    
                    const flameIntensity = (1 - dist / sprayLength) * (1 - angleDiff / (Math.PI / 2.5));
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 50) % 360 : 5 + flameIntensity * 55;
                    this.size = Math.max(2, Math.min(5, 3 + flameIntensity * 2));
                  }
                }
              }
            }
          } else if (fireEffectType === 'explosion' && explosionActive) {
            // å·¦2å³4 - ç«ç„°çˆ†è£‚ï¼šåŒæ‰‹å‡ºç°ç«ç„°ç”Ÿæˆï¼Œç«ç„°çš„å½¢çŠ¶ä¸€å®šè¦éå¸¸çš„æ˜æ˜¾ï¼ŒåŒæ‰‹éƒ½è¦æœ‰
            const elapsed = Date.now() - explosionStartTime;
            const duration = 2000; // å»¶é•¿çˆ†ç‚¸æŒç»­æ—¶é—´åˆ°2ç§’
            const progress = Math.min(1, elapsed / duration);
            
            if (progress < 1) {
              const leftHand = currentHandsData.find(h => h.handedness === 'Left') || currentHandsData[0];
              const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
              
              // å¤„ç†å³æ‰‹ç«ç„°ç”Ÿæˆ
              if (rightHand) {
                const explosionX = rightHand.palmX * canvas.width;
                const explosionY = rightHand.palmY * canvas.height;
                
                const dx = this.x - explosionX;
                const dy = this.y - explosionY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxRadius = 400;
                
                if (dist < maxRadius) {
                  // ç«ç„°ç”Ÿæˆæ•ˆæœï¼šç²’å­è¢«å¸å¼•åˆ°ç«ç„°ä¸­å¿ƒï¼Œç„¶åå‘ä¸Šå–·å°„
                  const flameIntensity = (1 - progress) * (1 - dist / maxRadius);
                  
                  // å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å…¥ç«ç„°ä¸­å¿ƒ
                  const pullForce = flameIntensity * 2.0;
                  if (dist > 0) {
                    this.vx += (dx / dist) * pullForce;
                    this.vy += (dy / dist) * pullForce;
                  }
                  
                  // ä¸Šå‡åŠ›ï¼šç²’å­å‘ä¸Šå–·å°„ï¼ˆå½¢æˆç«ç„°å½¢çŠ¶ï¼‰
                  const upwardForce = flameIntensity * 3.0;
                  this.vy -= upwardForce;
                  
                  // æ—‹è½¬æ•ˆæœï¼šç²’å­å›´ç»•ä¸­å¿ƒæ—‹è½¬ï¼ˆå¢å¼ºç«ç„°å½¢çŠ¶ï¼‰
                  const angle = Math.atan2(dy, dx) + Date.now() * 0.01;
                  const rotationForce = flameIntensity * 1.5;
                  this.vx += Math.cos(angle) * rotationForce;
                  this.vy += Math.sin(angle) * rotationForce;
                  
                  // éšæœºæ‰°åŠ¨ï¼ˆæ¨¡æ‹Ÿç«ç„°è·³åŠ¨ï¼‰
                  this.vx += (Math.random() - 0.5) * flameIntensity * 1.5;
                  this.vy += (Math.random() - 0.5) * flameIntensity * 1.5;
                  
                  // é¢œè‰²ï¼šç«ç„°è‰²ç³»ï¼ˆåº•éƒ¨çº¢è‰²ï¼Œä¸­é—´æ©™è‰²ï¼Œé¡¶éƒ¨é»„è‰²åˆ°ç™½è‰²ï¼‰
                  const heightRatio = Math.max(0, Math.min(1, (this.y - explosionY + 200) / 400));
                  if (heightRatio < 0.3) {
                    // åº•éƒ¨ï¼šæ·±çº¢è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 40) % 360 : 0 + flameIntensity * 10;
                  } else if (heightRatio < 0.6) {
                    // ä¸­é—´ï¼šæ©™è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 50) % 360 : 20 + flameIntensity * 20;
                  } else {
                    // é¡¶éƒ¨ï¼šé»„è‰²åˆ°ç™½è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 60) % 360 : 50 + flameIntensity * 10;
                  }
                  this.size = Math.max(3, Math.min(9, 4 + flameIntensity * 5)); // å¢å¤§ç²’å­å°ºå¯¸
                }
              }
              
              // å¤„ç†å·¦æ‰‹ç«ç„°ç”Ÿæˆ
              if (leftHand) {
                const explosionX = leftHand.palmX * canvas.width;
                const explosionY = leftHand.palmY * canvas.height;
                
                const dx = this.x - explosionX;
                const dy = this.y - explosionY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const maxRadius = 400;
                
                if (dist < maxRadius) {
                  // ç«ç„°ç”Ÿæˆæ•ˆæœï¼šç²’å­è¢«å¸å¼•åˆ°ç«ç„°ä¸­å¿ƒï¼Œç„¶åå‘ä¸Šå–·å°„
                  const flameIntensity = (1 - progress) * (1 - dist / maxRadius);
                  
                  // å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å…¥ç«ç„°ä¸­å¿ƒ
                  const pullForce = flameIntensity * 2.0;
                  if (dist > 0) {
                    this.vx += (dx / dist) * pullForce;
                    this.vy += (dy / dist) * pullForce;
                  }
                  
                  // ä¸Šå‡åŠ›ï¼šç²’å­å‘ä¸Šå–·å°„ï¼ˆå½¢æˆç«ç„°å½¢çŠ¶ï¼‰
                  const upwardForce = flameIntensity * 3.0;
                  this.vy -= upwardForce;
                  
                  // æ—‹è½¬æ•ˆæœï¼šç²’å­å›´ç»•ä¸­å¿ƒæ—‹è½¬ï¼ˆå¢å¼ºç«ç„°å½¢çŠ¶ï¼‰
                  const angle = Math.atan2(dy, dx) + Date.now() * 0.01;
                  const rotationForce = flameIntensity * 1.5;
                  this.vx += Math.cos(angle) * rotationForce;
                  this.vy += Math.sin(angle) * rotationForce;
                  
                  // éšæœºæ‰°åŠ¨ï¼ˆæ¨¡æ‹Ÿç«ç„°è·³åŠ¨ï¼‰
                  this.vx += (Math.random() - 0.5) * flameIntensity * 1.5;
                  this.vy += (Math.random() - 0.5) * flameIntensity * 1.5;
                  
                  // é¢œè‰²ï¼šç«ç„°è‰²ç³»ï¼ˆåº•éƒ¨çº¢è‰²ï¼Œä¸­é—´æ©™è‰²ï¼Œé¡¶éƒ¨é»„è‰²åˆ°ç™½è‰²ï¼‰
                  const heightRatio = Math.max(0, Math.min(1, (this.y - explosionY + 200) / 400));
                  if (heightRatio < 0.3) {
                    // åº•éƒ¨ï¼šæ·±çº¢è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 40) % 360 : 0 + flameIntensity * 10;
                  } else if (heightRatio < 0.6) {
                    // ä¸­é—´ï¼šæ©™è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 50) % 360 : 20 + flameIntensity * 20;
                  } else {
                    // é¡¶éƒ¨ï¼šé»„è‰²åˆ°ç™½è‰²
                    this.hue = rainbowMode ? (rainbowHue + flameIntensity * 60) % 360 : 50 + flameIntensity * 10;
                  }
                  this.size = Math.max(3, Math.min(9, 4 + flameIntensity * 5)); // å¢å¤§ç²’å­å°ºå¯¸
                }
              }
            } else {
              // çˆ†ç‚¸ç»“æŸ
              explosionActive = false;
            }
          } else if (fireEffectType === 'phoenix' && currentHandsData.length >= 2) {
            // å·¦2å³5 - ç«ç„°å‡¤å‡°ï¼šæ‹–åŠ¨æ‰‹æ—¶ç”Ÿæˆ"å‡¤å‡°å½¢çŠ¶æˆ–å°¾è¿¹ç«ç„°"ï¼Œä¼šè‡ªåŠ¨è·Ÿéšé£è¡Œ
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              
              // æ›´æ–°å‡¤å‡°ä½ç½®ï¼ˆå¹³æ»‘è·Ÿéšå³æ‰‹ï¼‰
              phoenixPosition.x += (handX - phoenixPosition.x) * 0.1;
              phoenixPosition.y += (handY - phoenixPosition.y) * 0.1;
              
              // æ·»åŠ å°¾è¿¹ç‚¹
              phoenixTrail.push({ x: phoenixPosition.x, y: phoenixPosition.y, time: Date.now() });
              if (phoenixTrail.length > 20) {
                phoenixTrail.shift();
              }
              
              // è®¡ç®—ç²’å­åˆ°å‡¤å‡°çš„è·ç¦»
              const dx = this.x - phoenixPosition.x;
              const dy = this.y - phoenixPosition.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 180; // å¢åŠ å½±å“èŒƒå›´
              
              if (dist < radius) {
                // å‡¤å‡°å½¢çŠ¶ï¼šç²’å­å½¢æˆç¿…è†€å’Œå°¾è¿¹
                const angle = Math.atan2(dy, dx);
                const wingPattern = Math.sin(angle * 2) * 0.5; // å¢å¼ºç¿…è†€å½¢çŠ¶
                
                // å‘å¿ƒåŠ›ï¼šå½¢æˆå‡¤å‡°èº«ä½“ï¼ˆå¢å¼ºï¼‰
                const bodyForce = (1 - dist / radius) * 0.8; // å¢å¼ºå‘å¿ƒåŠ›
                if (dist > 0) {
                  this.vx += (dx / dist) * bodyForce;
                  this.vy += (dy / dist) * bodyForce;
                }
                
                // ç¿…è†€æ•ˆæœï¼šç²’å­æ²¿ç¿…è†€æ–¹å‘æ’åˆ—ï¼ˆå¢å¼ºï¼‰
                const wingAngle = angle + wingPattern;
                const wingForce = (1 - dist / radius) * 0.6; // å¢å¼ºç¿…è†€åŠ›
                this.vx += Math.cos(wingAngle) * wingForce;
                this.vy += Math.sin(wingAngle) * wingForce;
                
                // å°¾è¿¹æ•ˆæœï¼šç²’å­è·Ÿéšå°¾è¿¹ï¼ˆå¢å¼ºï¼‰
                if (phoenixTrail.length > 1) {
                  const tailIndex = Math.floor((dist / radius) * (phoenixTrail.length - 1));
                  if (tailIndex < phoenixTrail.length) {
                    const tailPoint = phoenixTrail[tailIndex];
                    const tailDx = tailPoint.x - this.x;
                    const tailDy = tailPoint.y - this.y;
                    const tailDist = Math.sqrt(tailDx * tailDx + tailDy * tailDy);
                    if (tailDist > 0) {
                      const tailForce = (1 - dist / radius) * 0.4; // å¢å¼ºå°¾è¿¹åŠ›
                      this.vx += (tailDx / tailDist) * tailForce;
                      this.vy += (tailDy / tailDist) * tailForce;
                    }
                  }
                }
                
                // æ—‹è½¬æ•ˆæœï¼šç²’å­å›´ç»•å‡¤å‡°æ—‹è½¬
                const rotationAngle = angle + Date.now() * 0.003;
                const rotationForce = (1 - dist / radius) * 0.3;
                this.vx += Math.cos(rotationAngle) * rotationForce;
                this.vy += Math.sin(rotationAngle) * rotationForce;
                
                // é¢œè‰²ï¼šå‡¤å‡°è‰²ç³»ï¼ˆé‡‘çº¢æ¸å˜ï¼‰
                const phoenixIntensity = (1 - dist / radius);
                this.hue = rainbowMode ? (rainbowHue + phoenixIntensity * 50) % 360 : 10 + phoenixIntensity * 50; // 10-60 (æ·±çº¢åˆ°é‡‘é»„)
                this.size = Math.max(2.5, Math.min(6, 3.5 + phoenixIntensity * 2.5)); // å¢å¤§ç²’å­å°ºå¯¸
              }
            }
          }
        }
        
        // æ°´ç³»æ•ˆæœå¤„ç†ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        if (waterEffectType && !isHandsClosing) {
          const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          
          if (waterEffectType === 'rain' && currentHandsData.length >= 2) {
            // æ¡æ‹³+å³æ‰‹2 - é›¨æ»´ç”Ÿæˆï¼šä»æ•´ä¸ªå±å¹•ä¸Šæ–¹éšæœºä½ç½®ç”Ÿæˆé›¨æ»´ï¼Œä»¥é‡åŠ›åŠ é€Ÿåº¦ä¸‹è½ï¼Œç¢°æ’äº§ç”Ÿæº…å°„
            // ä»å±å¹•ä¸Šæ–¹éšæœºä½ç½®ç”Ÿæˆé›¨æ»´ï¼ˆæ•´ä¸ªå±å¹•ï¼‰
            if (Math.random() < 0.6) { // å¢åŠ ç”Ÿæˆé¢‘ç‡
              rainParticles.push({
                x: Math.random() * canvas.width, // ä»å±å¹•ä¸Šæ–¹éšæœºä½ç½®ç”Ÿæˆ
                y: -20 - Math.random() * 100, // ä»å±å¹•ä¸Šæ–¹å¼€å§‹
                vx: (Math.random() - 0.5) * 2, // è½»å¾®æ¨ªå‘åç§»
                vy: 4 + Math.random() * 5, // å¢åŠ ä¸‹è½é€Ÿåº¦
                size: 2 + Math.random() * 3, // é›¨æ»´å°ºå¯¸
                life: 1.0
              });
            }
              
            // æ›´æ–°é›¨æ»´
            rainParticles = rainParticles.filter(drop => {
              drop.x += drop.vx;
              drop.y += drop.vy;
              drop.vy += 0.4; // å¢åŠ é‡åŠ›åŠ é€Ÿåº¦ï¼ˆæ›´å¿«ä¸‹è½ï¼‰
              drop.life -= 0.01;
              
              // ç¢°æ’æ£€æµ‹ï¼ˆä¸åœ°é¢ï¼‰- ç¢°ç¢æ•ˆæœ
              const groundY = canvas.height - 20; // åœ°é¢ä½ç½®
              if (drop.y >= groundY) {
                // äº§ç”Ÿæ›´å¤šæº…å°„ç²’å­ï¼ˆæ¨¡æ‹Ÿç¢°ç¢æ•ˆæœï¼‰
                const splashCount = 10 + Math.floor(Math.random() * 10); // 10-20ä¸ªæº…å°„ç²’å­
                for (let i = 0; i < splashCount; i++) {
                  const splashAngle = (i / splashCount) * Math.PI * 2 + Math.random() * 0.5;
                  const splashSpeed = 8 + Math.random() * 10; // æº…å°„é€Ÿåº¦
                  rainParticles.push({
                    x: drop.x + (Math.random() - 0.5) * 5,
                    y: groundY,
                    vx: Math.cos(splashAngle) * splashSpeed,
                    vy: -Math.abs(Math.sin(splashAngle)) * splashSpeed - Math.random() * 3, // å‘ä¸Šæº…å°„
                    size: 1 + Math.random() * 2, // æº…å°„ç²’å­è¾ƒå°
                    life: 0.4 + Math.random() * 0.3 // çŸ­æš‚å­˜æ´»
                  });
                }
                return false; // ç§»é™¤åŸé›¨æ»´ï¼ˆç¢°ç¢äº†ï¼‰
              }
              
              // é›¨æ»´å½±å“é™„è¿‘ç²’å­ï¼ˆå¢å¼ºå½±å“èŒƒå›´ï¼‰
              const dx = this.x - drop.x;
              const dy = this.y - drop.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < drop.size * 10) { // æ‰©å¤§å½±å“èŒƒå›´
                // ç²’å­è¢«é›¨æ»´æ¨åŠ¨ï¼ˆå¢å¼ºåŠ›åº¦ï¼‰
                const force = (1 - dist / (drop.size * 10)) * 0.6;
                if (dist > 0) {
                  this.vx += (dx / dist) * force;
                  this.vy += (dy / dist) * force;
                }
                
                // é¢œè‰²ï¼šè“è‰²ç³»ï¼ˆå¢å¼ºäº®åº¦ï¼‰
                const rainIntensity = (1 - dist / (drop.size * 10));
                this.hue = rainbowMode ? (rainbowHue + dist * 0.1) % 360 : 200 + rainIntensity * 40;
                this.size = Math.max(2, Math.min(5, 2.5 + rainIntensity * 2.5));
              }
              
              return drop.life > 0 && drop.y < canvas.height + 50;
            });
          } else if (waterEffectType === 'condense' && currentHandsData.length >= 2) {
            // å·¦4å³2 - ç²’å­å‡ç»“ï¼šå°†ä½æµ“åº¦ç²’å­èšåˆæˆè¾ƒå¤§æ°´æ»´
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              
              // è®¡ç®—ç²’å­åˆ°æ‰‹çš„è·ç¦»
              const dx = handX - this.x;
              const dy = handY - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 250;
              
              if (dist < radius && dist > 0) {
                // å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å¼•åˆ°æ‰‹éƒ¨
                const pullForce = (1 - dist / radius) * 0.8;
                this.vx += (dx / dist) * pullForce;
                this.vy += (dy / dist) * pullForce;
                
                // æ£€æŸ¥ä¸å…¶ä»–ç²’å­çš„åˆå¹¶ï¼ˆç®€åŒ–ç‰ˆï¼Œä½¿ç”¨æœ€è¿‘é‚»æ£€æµ‹ï¼‰
                let nearestDist = Infinity;
                let nearestParticle = null;
                particles.forEach(p => {
                  if (p !== this) {
                    const pdx = p.x - this.x;
                    const pdy = p.y - this.y;
                    const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                    if (pdist < nearestDist && pdist < 15) { // åˆå¹¶è·ç¦»é˜ˆå€¼
                      nearestDist = pdist;
                      nearestParticle = p;
                    }
                  }
                });
                
                // å¦‚æœæ‰¾åˆ°è¶³å¤Ÿè¿‘çš„ç²’å­ï¼Œåˆå¹¶ï¼ˆå¢å¼ºåˆå¹¶æ•ˆæœï¼‰
                if (nearestParticle && nearestDist < 15) { // æ”¾å®½åˆå¹¶è·ç¦»
                  const mergeForce = (1 - nearestDist / 15) * 1.0; // å¢å¼ºåˆå¹¶åŠ›
                  const mergeDx = nearestParticle.x - this.x;
                  const mergeDy = nearestParticle.y - this.y;
                  if (nearestDist > 0) {
                    this.vx += (mergeDx / nearestDist) * mergeForce;
                    this.vy += (mergeDy / nearestDist) * mergeForce;
                  }
                  
                  // å¢å¤§ç²’å­å°ºå¯¸ï¼ˆæ¨¡æ‹Ÿåˆå¹¶ï¼‰
                  this.size = Math.min(7, this.size + 0.15); // å¢å¤§æœ€å¤§å°ºå¯¸
                } else {
                  // å‘æ‰‹éƒ¨ä¸­å¿ƒå¸å¼•ï¼ˆå¢å¼ºå¸å¼•åŠ›ï¼‰
                  const attractForce = (1 - dist / radius) * 0.6; // å¢å¼ºå¸å¼•åŠ›
                  if (dist > 0) {
                    this.vx += (dx / dist) * attractForce;
                    this.vy += (dy / dist) * attractForce;
                  }
                  
                  // æ·»åŠ æ—‹è½¬æ•ˆæœï¼ˆå¢å¼ºåŠ¨æ€æ„Ÿï¼‰
                  const rotationAngle = Math.atan2(dy, dx) + Date.now() * 0.005;
                  const rotationForce = (1 - dist / radius) * 0.3;
                  this.vx += Math.cos(rotationAngle) * rotationForce;
                  this.vy += Math.sin(rotationAngle) * rotationForce;
                }
                
                // é¢œè‰²ï¼šæ·±è“è‰²ç³»ï¼ˆå¢å¼ºäº®åº¦ï¼‰
                const condenseIntensity = (1 - dist / radius);
                this.hue = rainbowMode ? (rainbowHue + dist * 0.1) % 360 : 210 + condenseIntensity * 30; // 210-240 (æ·±è“åˆ°è“)
                this.size = Math.max(2.5, Math.min(7, 3.5 + condenseIntensity * 3.5)); // å¢å¤§ç²’å­å°ºå¯¸
              }
            }
          } else if (waterEffectType === 'split' && currentHandsData.length >= 2) {
            // å·¦5å³2 - æ°´æµåˆ†è£‚ï¼šä¸»æµè¢«æ‰‹åŠ¿åˆ†å‰²æˆä¸¤ä¸ªå­æµ
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              splitStreamCenterX = rightHand.palmX * canvas.width;
              splitStreamCenterY = rightHand.palmY * canvas.height;
              
              // è®¡ç®—ç²’å­åˆ°åˆ†è£‚ä¸­å¿ƒçš„è·ç¦»
              const dx = this.x - splitStreamCenterX;
              const dy = this.y - splitStreamCenterY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 200;
              
              if (dist < radius && dist > 0) {
                // è®¡ç®—ç²’å­ç›¸å¯¹äºåˆ†è£‚ä¸­å¿ƒçš„è§’åº¦
                const angle = Math.atan2(dy, dx);
                
                // æ ¹æ®ç²’å­åœ¨åˆ†è£‚ä¸­å¿ƒçš„å“ªä¸€ä¾§ï¼Œå†³å®šæµå‘ï¼ˆå¢å¼ºåˆ†æµæ•ˆæœï¼‰
                // ä½¿ç”¨Yåæ ‡åˆ¤æ–­ï¼šä¸Šæ–¹ç²’å­å‘å·¦åˆ†æµï¼Œä¸‹æ–¹ç²’å­å‘å³åˆ†æµ
                const splitAngle = dy > 0 ? -Math.PI / 3 : Math.PI / 3; // å¢å¤§åˆ†æµè§’åº¦åˆ°60åº¦
                
                // è®¡ç®—åˆ†æµæ–¹å‘
                const targetAngle = angle + splitAngle;
                const splitForce = (1 - dist / radius) * 1.8; // å¢å¼ºåˆ†æµåŠ›
                
                // åº”ç”¨åˆ†æµåŠ›
                this.vx += Math.cos(targetAngle) * splitForce;
                this.vy += Math.sin(targetAngle) * splitForce;
                
                // æ·»åŠ å‚ç›´äºåˆ†æµæ–¹å‘çš„åŠ›ï¼ˆå¢å¼ºåˆ†è£‚æ•ˆæœï¼‰
                const perpAngle = targetAngle + Math.PI / 2;
                const perpForce = (1 - dist / radius) * 0.8; // å¢å¼ºå‚ç›´åŠ›
                this.vx += Math.cos(perpAngle) * perpForce * Math.sin(dist * 0.1);
                this.vy += Math.sin(perpAngle) * perpForce * Math.sin(dist * 0.1);
                
                // æ·»åŠ å¾„å‘åŠ›ï¼ˆå¢å¼ºåˆ†è£‚æ•ˆæœï¼‰
                const radialForce = (1 - dist / radius) * 0.6;
                this.vx += (dx / dist) * radialForce;
                this.vy += (dy / dist) * radialForce;
                
                // é¢œè‰²ï¼šé’è‰²ç³»ï¼ˆå¢å¼ºäº®åº¦ï¼‰
                const splitIntensity = (1 - dist / radius);
                this.hue = rainbowMode ? (rainbowHue + angle * 57.3) % 360 : 180 + splitIntensity * 40; // 180-220 (é’åˆ°è“)
                this.size = Math.max(2.5, Math.min(6, 3 + splitIntensity * 3)); // å¢å¤§ç²’å­å°ºå¯¸
              }
            }
          }
        }
        
        // é«˜çº§ç»„åˆæ•ˆæœå¤„ç†ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
        if (advancedEffectType && !isHandsClosing) {
          const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          
          if (currentHandsData.length >= 2) {
            const leftHand = currentHandsData.find(h => h.handedness === 'Left') || currentHandsData[0];
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            
            if (leftHand && rightHand) {
              const leftX = leftHand.palmX * canvas.width;
              const leftY = leftHand.palmY * canvas.height;
              const rightX = rightHand.palmX * canvas.width;
              const rightY = rightHand.palmY * canvas.height;
              
              if (advancedEffectType === 'lightning') {
                // å³æ‰‹5ï¼Œå·¦æ‰‹5 - å½¢æˆåŒæ‰‹é›·ç”µçƒ
                // è®¡ç®—ä¸¤æ‰‹ä¸­å¿ƒç‚¹
                const ballCenterX = (leftX + rightX) / 2;
                const ballCenterY = (leftY + rightY) / 2;
                
                // è®¡ç®—ä¸¤æ‰‹è·ç¦»ï¼Œå†³å®šé›·ç”µçƒå¤§å°
                const handsDistance = Math.sqrt(Math.pow(rightX - leftX, 2) + Math.pow(rightY - leftY, 2));
                const ballRadius = Math.min(200, Math.max(50, handsDistance * 0.5));
                
                // æ›´æ–°é›·ç”µçƒå‚æ•°
                lightningBoltStartX = ballCenterX;
                lightningBoltStartY = ballCenterY;
                lightningBoltEndX = ballRadius; // ä½¿ç”¨è¿™ä¸ªå˜é‡å­˜å‚¨åŠå¾„
                
                // ç²’å­å—é›·ç”µçƒå½±å“
                const dx = ballCenterX - this.x;
                const dy = ballCenterY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < ballRadius * 2) {
                  // ç²’å­è¢«å¸å¼•åˆ°é›·ç”µçƒè¡¨é¢
                  const targetRadius = ballRadius;
                  const distFromSurface = Math.abs(dist - targetRadius);
                  
                  if (distFromSurface < 150) {
                    // å¾„å‘åŠ›ï¼šæ‹‰å‘é›·ç”µçƒè¡¨é¢
                    const radialForce = (1 - distFromSurface / 150) * 2.0;
                    if (dist > 0) {
                      if (dist < targetRadius) {
                        // åœ¨çƒå†…ï¼Œå‘å¤–æ¨
                        this.vx -= (dx / dist) * radialForce;
                        this.vy -= (dy / dist) * radialForce;
                      } else {
                        // åœ¨çƒå¤–ï¼Œå‘å†…æ‹‰
                        this.vx += (dx / dist) * radialForce;
                        this.vy += (dy / dist) * radialForce;
                      }
                    }
                    
                    // åˆ‡å‘åŠ›ï¼šå›´ç»•é›·ç”µçƒæ—‹è½¬
                    const angle = Math.atan2(dy, dx) + Date.now() * 0.01;
                    const tangentForce = (1 - distFromSurface / 150) * 1.5;
                    this.vx += Math.cos(angle + Math.PI / 2) * tangentForce;
                    this.vy += Math.sin(angle + Math.PI / 2) * tangentForce;
                    
                    // æ·»åŠ ç”µå‡»æ•ˆæœï¼ˆéšæœºéœ‡åŠ¨ï¼‰
                    this.vx += (Math.random() - 0.5) * 2;
                    this.vy += (Math.random() - 0.5) * 2;
                    
                    // é¢œè‰²ï¼šäº®ç™½è‰²åˆ°è“è‰²ï¼ˆé›·ç”µè‰²ï¼‰
                    const lightningIntensity = (1 - distFromSurface / 150);
                    this.hue = rainbowMode ? (rainbowHue + angle * 57.3) % 360 : 200 + lightningIntensity * 50;
                    this.size = Math.max(2, Math.min(7, 3 + lightningIntensity * 4));
                  }
                }
              }
            }
          }
        }
        
        // ç©ºé—´æ‰­æ›²æ•ˆæœå¤„ç†ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
        if (spaceEffectType && !isHandsClosing) {
          const currentHandsData = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          
          if (spaceEffectType === 'blackhole' && currentHandsData.length >= 2) {
            // å·¦4å³1 - è™«æ´å¸å¼•ï¼šå³æ‰‹ä½ç½®ç”Ÿæˆå°é»‘æ´ï¼Œå¸å¼•æ‰€æœ‰ç²’å­ï¼Œæ‰‹è¶ŠæŠ¬å¸å¼•è¶Šå¼º
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              blackHoleX = rightHand.palmX * canvas.width;
              blackHoleY = rightHand.palmY * canvas.height;
              
              // è®¡ç®—æ‰‹çš„é«˜åº¦ï¼ˆYåæ ‡è¶Šå°ï¼Œæ‰‹è¶Šé«˜ï¼‰ï¼Œæ‰‹è¶ŠæŠ¬å¸å¼•è¶Šå¼º
              const handHeight = 1 - (rightHand.palmY); // å½’ä¸€åŒ–åˆ°0-1ï¼Œæ‰‹è¶Šé«˜å€¼è¶Šå¤§
              blackHoleIntensity = Math.max(0.3, handHeight); // æœ€å°å¼ºåº¦0.3ï¼Œæœ€å¤§1.0
              
              const dx = blackHoleX - this.x;
              const dy = blackHoleY - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const radius = 300 + blackHoleIntensity * 200; // å½±å“èŒƒå›´éšå¼ºåº¦å˜åŒ–
              
              if (dist < radius && dist > 0) {
                // å¼ºå¤§çš„å‘å¿ƒåŠ›ï¼šç²’å­è¢«å¸å…¥è™«æ´
                const pullForce = (1 - dist / radius) * blackHoleIntensity * 3.0; // éå¸¸å¼ºçš„å¸å¼•åŠ›
                this.vx += (dx / dist) * pullForce;
                this.vy += (dy / dist) * pullForce;
                
                // æ—‹è½¬æ•ˆæœï¼šç²’å­å›´ç»•è™«æ´æ—‹è½¬
                const rotationAngle = Math.atan2(dy, dx) + Date.now() * 0.01; // å¿«é€Ÿæ—‹è½¬
                const rotationForce = (1 - dist / radius) * blackHoleIntensity * 1.5;
                this.vx += Math.cos(rotationAngle) * rotationForce;
                this.vy += Math.sin(rotationAngle) * rotationForce;
                
                // é¢œè‰²ï¼šæ·±ç´«è‰²åˆ°é»‘è‰²
                const blackHoleIntensityLocal = blackHoleIntensity * (1 - dist / radius);
                this.hue = rainbowMode ? (rainbowHue + dist * 0.2) % 360 : 270 + blackHoleIntensityLocal * 30; // 270-300 (æ·±ç´«åˆ°ç´«)
                this.size = Math.max(1.5, Math.min(4, 2 + blackHoleIntensityLocal * 2));
              }
            }
          } else if (spaceEffectType === 'portal' && currentHandsData.length >= 2) {
            // å·¦4å³2 - ç©ºé—´é—¨ï¼šå³æ‰‹ç”»åœ†ä¼šç”Ÿæˆä¼ é€é—¨æ ·å¼çš„ç²’å­åœ†ç¯
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              
              // æ£€æµ‹ç”»åœ†åŠ¨ä½œï¼ˆé€šè¿‡æ‰‹çš„ä½ç½®å˜åŒ–ï¼‰
              const dx = handX - portalCenterX;
              const dy = handY - portalCenterY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              // å¦‚æœæ‰‹ç§»åŠ¨äº†ï¼Œæ›´æ–°ä¼ é€é—¨ä½ç½®å’Œå¤§å°
              if (dist > 10) {
                portalCenterX = handX;
                portalCenterY = handY;
                portalRadius = Math.min(150, Math.max(50, dist * 0.5)); // ä¼ é€é—¨åŠå¾„
              }
              
              portalRotation += 0.02; // ä¼ é€é—¨æ—‹è½¬
              
              // ç²’å­è¢«å¸å¼•åˆ°ä¼ é€é—¨åœ†ç¯
              const particleDx = portalCenterX - this.x;
              const particleDy = portalCenterY - this.y;
              const particleDist = Math.sqrt(particleDx * particleDx + particleDy * particleDy);
              
              // ç²’å­è¢«å¸å¼•åˆ°åœ†ç¯è¾¹ç¼˜ï¼ˆä¸æ˜¯ä¸­å¿ƒï¼‰
              const targetRadius = portalRadius;
              const distFromRing = Math.abs(particleDist - targetRadius);
              
              if (distFromRing < 100) {
                // è®¡ç®—ç²’å­åº”è¯¥åˆ°è¾¾çš„åœ†ç¯ä½ç½®
                const angle = Math.atan2(particleDy, particleDx) + portalRotation;
                const targetX = portalCenterX + Math.cos(angle) * targetRadius;
                const targetY = portalCenterY + Math.sin(angle) * targetRadius;
                
                const targetDx = targetX - this.x;
                const targetDy = targetY - this.y;
                const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                
                if (targetDist > 0) {
                  // å‘åœ†ç¯è¾¹ç¼˜ç§»åŠ¨
                  const ringForce = (1 - distFromRing / 100) * 1.5;
                  this.vx += (targetDx / targetDist) * ringForce;
                  this.vy += (targetDy / targetDist) * ringForce;
                  
                  // æ²¿åœ†ç¯æ—‹è½¬
                  const rotationAngle = angle + Math.PI / 2;
                  const rotationForce = (1 - distFromRing / 100) * 0.8;
                  this.vx += Math.cos(rotationAngle) * rotationForce;
                  this.vy += Math.sin(rotationAngle) * rotationForce;
                  
                  // é¢œè‰²ï¼šè“ç´«è‰²ç³»
                  const portalIntensity = (1 - distFromRing / 100);
                  this.hue = rainbowMode ? (rainbowHue + angle * 57.3) % 360 : 240 + portalIntensity * 40; // 240-280 (è“åˆ°ç´«)
                  this.size = Math.max(2, Math.min(4, 2.5 + portalIntensity * 1.5));
                }
              }
            }
          } else if (spaceEffectType === 'freeze') {
            // å·¦4å³4 - ç²’å­å†»ç»“ï¼šå³æ‰‹åšå¼ å¼€æ‰‹åŠ¿ â†’ ç²’å­ç«‹å³é™æ­¢ï¼›æ¡æ‹³ â†’ æ¢å¤è¿åŠ¨
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              if (rightHand.gesture === 'open' || rightHand.gesture === 'five') {
                // å¼ å¼€æ‰‹åŠ¿ï¼šå†»ç»“ç²’å­
                particlesFrozen = true;
                this.vx *= 0.1; // å‡ ä¹åœæ­¢
                this.vy *= 0.1;
                this.hue = rainbowMode ? rainbowHue % 360 : 200; // è“è‰²è¡¨ç¤ºå†»ç»“
                this.size = Math.max(1.5, Math.min(3, 2));
              } else if (rightHand.gesture === 'closed') {
                // æ¡æ‹³ï¼šæ¢å¤è¿åŠ¨
                particlesFrozen = false;
              }
            }
            
            // å¦‚æœç²’å­è¢«å†»ç»“ï¼Œå‡ ä¹åœæ­¢è¿åŠ¨
            if (particlesFrozen) {
              this.vx *= 0.05;
              this.vy *= 0.05;
            }
          } else if (spaceEffectType === 'rewind' && currentHandsData.length >= 2) {
            // å·¦4å³5 - æ—¶é—´å€’æµç²’å­ï¼šå³æ‰‹æ—‹è½¬æ—¶ï¼Œç²’å­è½¨è¿¹åå‘æ’­æ”¾ï¼Œå°±åƒæ—¶é—´å€’æµ
            const rightHand = currentHandsData.find(h => h.handedness === 'Right') || currentHandsData[1];
            if (rightHand) {
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              
              // æ£€æµ‹å³æ‰‹æ—‹è½¬ï¼ˆé€šè¿‡è®¡ç®—è§’åº¦å˜åŒ–ï¼‰
              const dx = handX - previousRightHandPosition.x;
              const dy = handY - previousRightHandPosition.y;
              const currentAngle = Math.atan2(dy, dx);
              
              // è®¡ç®—è§’åº¦å˜åŒ–
              const angleDiff = currentAngle - rightHandRotationAngle;
              rightHandRotationAngle = currentAngle;
              
              // å¦‚æœæ£€æµ‹åˆ°æ—‹è½¬ï¼Œæ¿€æ´»æ—¶é—´å€’æµ
              if (Math.abs(angleDiff) > 0.1) {
                rewindActive = true;
                
                // ä¿å­˜ç²’å­å†å²è½¨è¿¹ï¼ˆæ¯å¸§ä¿å­˜ï¼‰
                if (!this.history) {
                  this.history = [];
                }
                this.history.push({ x: this.x, y: this.y, vx: this.vx, vy: this.vy });
                if (this.history.length > 60) { // ä¿å­˜60å¸§å†å²
                  this.history.shift();
                }
              }
              
              // å¦‚æœæ—¶é—´å€’æµæ¿€æ´»ï¼Œåå‘æ’­æ”¾ç²’å­è½¨è¿¹
              if (rewindActive && this.history && this.history.length > 1) {
                // ä»å†å²ä¸­å–å›ä¹‹å‰çš„ä½ç½®å’Œé€Ÿåº¦
                const historyIndex = Math.floor(this.history.length * 0.5); // å–ä¸­é—´çš„å†å²å¸§
                if (historyIndex < this.history.length) {
                  const pastState = this.history[historyIndex];
                  const targetDx = pastState.x - this.x;
                  const targetDy = pastState.y - this.y;
                  const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                  
                  if (targetDist > 0) {
                    // å¼ºçƒˆçš„åå‘åŠ›ï¼šè®©ç²’å­å›åˆ°å†å²ä½ç½®
                    const rewindForce = 2.5; // éå¸¸å¼ºçš„åå‘åŠ›
                    this.vx += (targetDx / targetDist) * rewindForce;
                    this.vy += (targetDy / targetDist) * rewindForce;
                    
                    // åå‘é€Ÿåº¦
                    this.vx = -this.vx * 0.8;
                    this.vy = -this.vy * 0.8;
                  }
                }
                
                // é¢œè‰²ï¼šç»¿è‰²ç³»ï¼ˆè¡¨ç¤ºæ—¶é—´å€’æµï¼‰
                this.hue = rainbowMode ? (rainbowHue + this.x * 0.1) % 360 : 120 + Math.sin(Date.now() * 0.01) * 30; // 120-150 (ç»¿åˆ°é’ç»¿)
                this.size = Math.max(2, Math.min(5, 3 + Math.sin(Date.now() * 0.02) * 1));
              }
            }
          }
        }
        
        // åŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹ç¦ç”¨æ–‡å­—å½¢æˆæ•ˆæœ
        else if (isFormingText && !isHandsClosing && this.targetX !== null && this.targetY !== null) {
          const targetDx = this.targetX - this.x;
          const targetDy = this.targetY - this.y;
          const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
          
          if (targetDist > 2) {
            // å¼ºå¸å¼•åŠ›ï¼Œè®©ç²’å­å¿«é€Ÿç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
            const textForce = Math.min(0.3, targetDist / 100) * 0.25;
            this.vx += targetDx * textForce;
            this.vy += targetDy * textForce;
            this.vx *= 0.92; // å¢åŠ é˜»å°¼
            this.vy *= 0.92;
            
            // æ›´æ–°é¢œè‰²å’Œå¤§å°
            // å‚ä¸æ‹¼å­—çš„ç²’å­ç”¨åç²‰è‰²åŒºåˆ†
            this.hue = rainbowMode ? (rainbowHue + targetDist * 2) % 360 : 320;
            this.size = Math.max(1.8, Math.min(3.5, 2.5 + (100 - targetDist) / 100 * 1));
          } else {
            // å·²ç»åˆ°è¾¾ç›®æ ‡ä½ç½®
            this.x = this.targetX;
            this.y = this.targetY;
            this.vx *= 0.7;
            this.vy *= 0.7;
            this.hue = rainbowMode ? rainbowHue % 360 : 320;
            this.size = 2.5;
          }
        }

        // é˜»å°¼ï¼ˆåœ¨æ‰‹éƒ¨é™„è¿‘æ—¶å¢åŠ é˜»å°¼ï¼Œè®©ç²’å­æ›´å®¹æ˜“èšé›†ï¼‰
        // æ”¯æŒå¤šåªæ‰‹ï¼Œä½¿ç”¨æœ€å¼ºçš„é˜»å°¼
        let damping = 0.98;
        const currentHandsDataForDamping = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        if (currentHandsDataForDamping.length > 0) {
          for (let handIdx = 0; handIdx < currentHandsDataForDamping.length; handIdx++) {
            const hands = currentHandsDataForDamping[handIdx];
            const palmX = hands.palmX * canvas.width;
            const palmY = hands.palmY * canvas.height;
            const dx = palmX - this.x;
            const dy = palmY - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            let handDamping = 0.98;
            if (dist < 150 && (hands.gesture === 'open' || hands.gesture === 'five')) {
              handDamping = 0.95; // åœ¨æ‰‹éƒ¨é™„è¿‘æ—¶å¢åŠ é˜»å°¼
            } else if (hands.gesture === 'closed') {
              // æ¡æ‹³æ—¶å¢åŠ é˜»å°¼ï¼Œé˜²æ­¢ç²’å­ä¹±è·‘
              // æ ¹æ®é€Ÿåº¦åŠ¨æ€è°ƒæ•´é˜»å°¼ï¼šé€Ÿåº¦è¶Šå¿«ï¼Œé˜»å°¼è¶Šå¤§
              const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
              handDamping = speed > 8 ? 0.88 : 0.90; // é€Ÿåº¦è¶Šå¿«ï¼Œé˜»å°¼è¶Šå¤§
            }
            // ä½¿ç”¨æœ€å¼ºçš„é˜»å°¼ï¼ˆæœ€å°çš„å€¼ï¼‰
            damping = Math.min(damping, handDamping);
          }
        }
        this.vx *= damping;
        this.vy *= damping;

        this.x += this.vx;
        this.y += this.vy;

        // æ— æ‰‹åŠ¿æ—¶ç¼“æ…¢å˜å›åŸºè‰²
        const currentHandsDataForColor = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        if (currentHandsDataForColor.length === 0) {
          this.hue += (200 - this.hue) * 0.05;
          this.size = Math.max(1, this.size * 0.99);
        }
      }

      draw() {
        // ç»˜åˆ¶æ‹–å°¾
        if (trailMode && this.trail.length > 1) {
          ctx.save();
          ctx.shadowBlur = 0; // å…³é—­é˜´å½±ä»¥å‡è½»æ‹–å°¾çš„æ€§èƒ½å‹åŠ›
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            const alpha = i / this.trail.length * 0.5;
            ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;
            ctx.lineWidth = this.size * (i / this.trail.length);
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.restore();
        }

        // ç»˜åˆ¶ç²’å­
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.8)`;
        ctx.fill();
        ctx.shadowBlur = 8; // é™ä½é˜´å½±æ¨¡ç³ŠåŠå¾„ï¼Œæå‡æ€§èƒ½
        ctx.shadowColor = `hsla(${this.hue}, 70%, 60%, 0.6)`;
        
        // å¤–åœˆå…‰æ™•
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, 0.3)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    }

    // åˆå§‹åŒ–ç²’å­
    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle());
      }
    }

    // æ ¹æ®è®¾å¤‡ç±»å‹è‡ªé€‚åº”åˆå§‹ç²’å­æ•°é‡å’Œæ»‘å—èŒƒå›´ï¼ˆæ‰‹æœºä¸Šé»˜è®¤å°‘ä¸€ç‚¹ï¼Œä¿è¯æµç•…ï¼‰
    (function adaptForDevice() {
      const particleSlider = document.getElementById('particleCount');
      const particleValueSpan = document.getElementById('particleCountValue');
      if (!particleSlider || !particleValueSpan) return;

      if (isMobile) {
        particleCount = 450;
        particleSlider.min = 150;
        particleSlider.max = 900;
        particleSlider.value = particleCount;
        particleValueSpan.textContent = particleCount;

        // æ‰‹æœºé»˜è®¤æŠ˜å æ§åˆ¶é¢æ¿ï¼Œåªæ˜¾ç¤ºæ ‡é¢˜å’ŒæŒ‰é’®
        if (controls && controlsToggle && controlsContent) {
          controls.classList.add('collapsed');
          controlsToggle.textContent = 'å±•å¼€é¢æ¿';
        }
      } else {
        particleCount = 600;
        particleSlider.min = 200;
        particleSlider.max = 1200;
        particleSlider.value = particleCount;
        particleValueSpan.textContent = particleCount;
      }
    })();

    // æ§åˆ¶é¢æ¿å±•å¼€ / æ”¶èµ·
    if (controls && controlsToggle && controlsContent) {
      controlsToggle.addEventListener('click', () => {
        const collapsed = controls.classList.toggle('collapsed');
        controlsToggle.textContent = collapsed ? 'å±•å¼€é¢æ¿' : 'æ”¶èµ·é¢æ¿';
      });
    }

    initParticles();

    // ç”Ÿæˆæ–‡å­—ç²’å­ä½ç½®
    function generateTextParticles(text) {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      
      // ä½¿ç”¨æ”¯æŒä¸­æ–‡çš„å­—ä½“ï¼Œå¹¶æ ¹æ®å½“å‰ç”»å¸ƒå¤§å°è‡ªé€‚åº”å­—å·
      const baseSize = Math.min(canvas.width, canvas.height);
      // æ‰‹æœºä¸Šå­—ç¨å¾®å°ä¸€ç‚¹ï¼Œé¿å…è¶…å‡ºå±å¹•
      const fontSize = baseSize * (isMobile ? 0.22 : 0.28);

      tempCtx.fillStyle = '#ffffff';
      tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", "SimHei", Arial, sans-serif`;
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      
      // åœ¨canvasä¸­å¿ƒç»˜åˆ¶æ–‡å­—
      tempCtx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      // è·å–åƒç´ æ•°æ®
      const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const positions = [];
      
      // é‡‡æ ·åƒç´ ï¼Œè·å–æ–‡å­—ä½ç½®ï¼ˆæ¯éš”å‡ ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡ï¼Œé¿å…ç²’å­è¿‡å¤šï¼‰
      const step = 2; // å‡å°é‡‡æ ·æ­¥é•¿ï¼Œè®©æ–‡å­—æ›´æ¸…æ™°
      for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
          const index = (y * canvas.width + x) * 4;
          // æ£€æŸ¥åƒç´ æ˜¯å¦åœ¨æ–‡å­—èŒƒå›´å†…ï¼ˆalpha > 0ï¼‰
          if (data[index + 3] > 128) {
            positions.push({ x, y });
          }
        }
      }
      
      // å¦‚æœä½ç½®å¤ªå°‘ï¼Œå¢åŠ é‡‡æ ·å¯†åº¦
      if (positions.length < particleCount * 0.5) {
        const step2 = 1;
        for (let y = 0; y < canvas.height; y += step2) {
          for (let x = 0; x < canvas.width; x += step2) {
            const index = (y * canvas.width + x) * 4;
            if (data[index + 3] > 128) {
              // é¿å…é‡å¤æ·»åŠ 
              const exists = positions.some(p => Math.abs(p.x - x) < 2 && Math.abs(p.y - y) < 2);
              if (!exists) {
                positions.push({ x, y });
              }
            }
          }
        }
      }
      
      return positions;
    }

    // ç”ŸæˆåŠ¨ç‰©/ç‰©ä½“å½¢çŠ¶çš„ç²’å­ä½ç½®
    function generateShapeParticles(shapeType) {
      const positions = [];
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const baseSize = Math.min(canvas.width, canvas.height) * 0.3; // åŸºç¡€å¤§å°
      const step = 3; // ç²’å­é—´è·
      
      // æ ¹æ®å½¢çŠ¶ç±»å‹ç”Ÿæˆä¸åŒçš„ç‚¹é˜µ
      switch(shapeType) {
        case 'dog':
          // ç‹—çš„å½¢çŠ¶ï¼šæ›´ç”ŸåŠ¨çš„è®¾è®¡ - å¤´éƒ¨ï¼ˆåœ†å½¢ï¼Œå¸¦é¼»å­å’Œå˜´å·´ï¼‰+ èº«ä½“ï¼ˆæ¤­åœ†ï¼‰+ ä¸‹å‚è€³æœµ + å››æ¡è…¿ + å°¾å·´
          // å¤´éƒ¨
          generateCircle(positions, centerX, centerY - baseSize * 0.25, baseSize * 0.28, step);
          // é¼»å­ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX, centerY - baseSize * 0.15, baseSize * 0.05, step);
          // å˜´å·´ï¼ˆå°æ¤­åœ†ï¼‰
          generateEllipse(positions, centerX, centerY - baseSize * 0.05, baseSize * 0.08, baseSize * 0.05, step);
          // èº«ä½“ï¼ˆæ¤­åœ†ï¼‰
          generateEllipse(positions, centerX, centerY + baseSize * 0.25, baseSize * 0.45, baseSize * 0.35, step);
          // å·¦è€³ï¼ˆä¸‹å‚çš„ä¸‰è§’å½¢ï¼‰
          generateTriangle(positions, centerX - baseSize * 0.25, centerY - baseSize * 0.35, baseSize * 0.18, step);
          // å³è€³ï¼ˆä¸‹å‚çš„ä¸‰è§’å½¢ï¼‰
          generateTriangle(positions, centerX + baseSize * 0.25, centerY - baseSize * 0.35, baseSize * 0.18, step);
          // å‰å·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.25, centerY + baseSize * 0.5, baseSize * 0.1, baseSize * 0.2, step);
          // å‰å³è…¿
          generateEllipse(positions, centerX + baseSize * 0.1, centerY + baseSize * 0.5, baseSize * 0.1, baseSize * 0.2, step);
          // åå·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.15, centerY + baseSize * 0.55, baseSize * 0.1, baseSize * 0.2, step);
          // åå³è…¿
          generateEllipse(positions, centerX + baseSize * 0.2, centerY + baseSize * 0.55, baseSize * 0.1, baseSize * 0.2, step);
          // å°¾å·´ï¼ˆå‘ä¸Šå¼¯æ›²ï¼‰
          generateCurvedLine(positions, centerX + baseSize * 0.4, centerY + baseSize * 0.15, centerX + baseSize * 0.6, centerY - baseSize * 0.15, step);
          break;
        case 'cat':
          // çŒ«çš„å½¢çŠ¶ï¼šæ›´ç”ŸåŠ¨çš„è®¾è®¡ - å¤´éƒ¨ï¼ˆåœ†å½¢ï¼Œå¸¦å°–è€³æœµï¼‰+ èº«ä½“ï¼ˆæ¤­åœ†ï¼‰+ å››æ¡è…¿ + é•¿å°¾å·´
          // å¤´éƒ¨
          generateCircle(positions, centerX, centerY - baseSize * 0.25, baseSize * 0.26, step);
          // é¼»å­ï¼ˆå°ä¸‰è§’å½¢ï¼‰
          generateTriangle(positions, centerX, centerY - baseSize * 0.15, baseSize * 0.04, step);
          // å˜´å·´ï¼ˆå°æ¤­åœ†ï¼‰
          generateEllipse(positions, centerX, centerY - baseSize * 0.05, baseSize * 0.06, baseSize * 0.04, step);
          // èº«ä½“ï¼ˆæ¤­åœ†ï¼Œæ›´ä¿®é•¿ï¼‰
          generateEllipse(positions, centerX, centerY + baseSize * 0.2, baseSize * 0.38, baseSize * 0.28, step);
          // å·¦è€³ï¼ˆå°–ä¸‰è§’å½¢ï¼‰
          generateTriangle(positions, centerX - baseSize * 0.22, centerY - baseSize * 0.5, baseSize * 0.22, step);
          // å³è€³ï¼ˆå°–ä¸‰è§’å½¢ï¼‰
          generateTriangle(positions, centerX + baseSize * 0.22, centerY - baseSize * 0.5, baseSize * 0.22, step);
          // å‰å·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.22, centerY + baseSize * 0.45, baseSize * 0.08, baseSize * 0.18, step);
          // å‰å³è…¿
          generateEllipse(positions, centerX + baseSize * 0.08, centerY + baseSize * 0.45, baseSize * 0.08, baseSize * 0.18, step);
          // åå·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.12, centerY + baseSize * 0.5, baseSize * 0.08, baseSize * 0.18, step);
          // åå³è…¿
          generateEllipse(positions, centerX + baseSize * 0.18, centerY + baseSize * 0.5, baseSize * 0.08, baseSize * 0.18, step);
          // é•¿å°¾å·´ï¼ˆå‘ä¸Šå¼¯æ›²ï¼‰
          generateCurvedLine(positions, centerX + baseSize * 0.35, centerY + baseSize * 0.1, centerX + baseSize * 0.65, centerY - baseSize * 0.3, step);
          break;
        case 'panda':
          // ç†ŠçŒ«çš„å½¢çŠ¶ï¼šæ›´ç”ŸåŠ¨çš„è®¾è®¡ - å¤§åœ†å¤´ + å¤§èº«ä½“ + å°åœ†è€³ + å››æ¡è…¿ + çœ¼ç›åŒºåŸŸ
          // å¤´éƒ¨ï¼ˆå¤§åœ†å½¢ï¼‰
          generateCircle(positions, centerX, centerY - baseSize * 0.15, baseSize * 0.38, step);
          // å·¦çœ¼åŒºåŸŸï¼ˆé»‘è‰²åœ†å½¢ï¼‰
          generateCircle(positions, centerX - baseSize * 0.12, centerY - baseSize * 0.2, baseSize * 0.08, step);
          // å³çœ¼åŒºåŸŸï¼ˆé»‘è‰²åœ†å½¢ï¼‰
          generateCircle(positions, centerX + baseSize * 0.12, centerY - baseSize * 0.2, baseSize * 0.08, step);
          // é¼»å­ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX, centerY - baseSize * 0.05, baseSize * 0.06, step);
          // èº«ä½“ï¼ˆå¤§æ¤­åœ†ï¼‰
          generateEllipse(positions, centerX, centerY + baseSize * 0.35, baseSize * 0.5, baseSize * 0.42, step);
          // å·¦è€³ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX - baseSize * 0.28, centerY - baseSize * 0.35, baseSize * 0.14, step);
          // å³è€³ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX + baseSize * 0.28, centerY - baseSize * 0.35, baseSize * 0.14, step);
          // å‰å·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.3, centerY + baseSize * 0.6, baseSize * 0.12, baseSize * 0.25, step);
          // å‰å³è…¿
          generateEllipse(positions, centerX + baseSize * 0.15, centerY + baseSize * 0.6, baseSize * 0.12, baseSize * 0.25, step);
          // åå·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.2, centerY + baseSize * 0.65, baseSize * 0.12, baseSize * 0.25, step);
          // åå³è…¿
          generateEllipse(positions, centerX + baseSize * 0.25, centerY + baseSize * 0.65, baseSize * 0.12, baseSize * 0.25, step);
          break;
        case 'dinosaur':
          // æé¾™çš„å½¢çŠ¶ï¼šæ›´ç”ŸåŠ¨çš„è®¾è®¡ - é•¿è„–å­ + å°å¤´ + å¤§èº«ä½“ + é•¿å°¾å·´ + å››æ¡è…¿
          // å¤´éƒ¨ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX - baseSize * 0.35, centerY - baseSize * 0.45, baseSize * 0.12, step);
          // çœ¼ç›ï¼ˆå°åœ†å½¢ï¼‰
          generateCircle(positions, centerX - baseSize * 0.38, centerY - baseSize * 0.48, baseSize * 0.03, step);
          // å˜´å·´ï¼ˆå°æ¤­åœ†ï¼‰
          generateEllipse(positions, centerX - baseSize * 0.32, centerY - baseSize * 0.42, baseSize * 0.06, baseSize * 0.04, step);
          // é•¿è„–å­ï¼ˆSå½¢æ›²çº¿ï¼‰
          generateCurvedLine(positions, centerX - baseSize * 0.35, centerY - baseSize * 0.33, centerX - baseSize * 0.15, centerY + baseSize * 0.05, step);
          // èº«ä½“ï¼ˆå¤§æ¤­åœ†ï¼‰
          generateEllipse(positions, centerX, centerY + baseSize * 0.25, baseSize * 0.45, baseSize * 0.35, step);
          // å‰å·¦è…¿
          generateEllipse(positions, centerX - baseSize * 0.25, centerY + baseSize * 0.5, baseSize * 0.12, baseSize * 0.3, step);
          // å‰å³è…¿
          generateEllipse(positions, centerX - baseSize * 0.05, centerY + baseSize * 0.5, baseSize * 0.12, baseSize * 0.3, step);
          // åå·¦è…¿
          generateEllipse(positions, centerX + baseSize * 0.15, centerY + baseSize * 0.55, baseSize * 0.12, baseSize * 0.3, step);
          // åå³è…¿
          generateEllipse(positions, centerX + baseSize * 0.35, centerY + baseSize * 0.55, baseSize * 0.12, baseSize * 0.3, step);
          // é•¿å°¾å·´ï¼ˆå‘åå»¶ä¼¸ï¼Œç•¥å¾®å‘ä¸Šï¼‰
          generateCurvedLine(positions, centerX + baseSize * 0.45, centerY + baseSize * 0.2, centerX + baseSize * 0.75, centerY - baseSize * 0.1, step);
          break;
      }
      
      return positions;
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆåœ†å½¢ç‚¹é˜µ
    function generateCircle(positions, cx, cy, radius, step) {
      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 20) {
        for (let r = 0; r < radius; r += step) {
          const x = cx + Math.cos(angle) * r;
          const y = cy + Math.sin(angle) * r;
          positions.push({ x, y });
        }
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆæ¤­åœ†ç‚¹é˜µ
    function generateEllipse(positions, cx, cy, rx, ry, step) {
      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 20) {
        for (let t = 0; t < 1; t += 0.1) {
          const r = t;
          const x = cx + Math.cos(angle) * rx * r;
          const y = cy + Math.sin(angle) * ry * r;
          positions.push({ x, y });
        }
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆä¸‰è§’å½¢ç‚¹é˜µ
    function generateTriangle(positions, cx, cy, size, step) {
      const points = [
        { x: cx, y: cy - size },
        { x: cx - size, y: cy + size },
        { x: cx + size, y: cy + size }
      ];
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        generateLine(positions, p1.x, p1.y, p2.x, p2.y, step);
      }
      // å¡«å……ä¸‰è§’å½¢å†…éƒ¨
      for (let y = cy - size; y <= cy + size; y += step) {
        for (let x = cx - size; x <= cx + size; x += step) {
          if (isPointInTriangle(x, y, points[0], points[1], points[2])) {
            positions.push({ x, y });
          }
        }
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
    function isPointInTriangle(px, py, p1, p2, p3) {
      const d1 = (px - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (py - p2.y);
      const d2 = (px - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (py - p3.y);
      const d3 = (px - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (py - p1.y);
      return (d1 >= 0 && d2 >= 0 && d3 >= 0) || (d1 <= 0 && d2 <= 0 && d3 <= 0);
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆç›´çº¿ç‚¹é˜µ
    function generateLine(positions, x1, y1, x2, y2, step) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const steps = Math.ceil(dist / step);
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        positions.push({ x: x1 + dx * t, y: y1 + dy * t });
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå¼¯æ›²çº¿æ¡
    function generateCurvedLine(positions, x1, y1, x2, y2, step) {
      const midX = (x1 + x2) / 2 + (y2 - y1) * 0.3;
      const midY = (y1 + y2) / 2 - (x2 - x1) * 0.3;
      const steps = 20;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * midX + t * t * x2;
        const y = (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * midY + t * t * y2;
        positions.push({ x, y });
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆçŸ©å½¢ç‚¹é˜µ
    function generateRectangle(positions, cx, cy, width, height, step) {
      const halfW = width / 2;
      const halfH = height / 2;
      for (let x = cx - halfW; x <= cx + halfW; x += step) {
        for (let y = cy - halfH; y <= cy + halfH; y += step) {
          positions.push({ x, y });
        }
      }
    }

    // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆé”¯é½¿çŠ¶çº¿æ¡ï¼ˆç”¨äºé¸¡å† ï¼‰
    function generateZigzag(positions, cx, cy, size, step) {
      const points = 5;
      let lastX = cx - size / 2;
      let lastY = cy;
      for (let i = 0; i < points; i++) {
        const x = cx - size / 2 + (size / (points - 1)) * i;
        const y = cy + (i % 2 === 0 ? -size * 0.3 : 0);
        if (i > 0) {
          generateLine(positions, lastX, lastY, x, y, step);
        }
        lastX = x;
        lastY = y;
        positions.push({ x, y });
      }
    }

    // ç”Ÿæˆä¸¤ä¸ªå°äººè·³èˆçš„ç²’å­ä½ç½®
    function generateDancingFigures(frame = 0) {
      const positions = [];
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const scale = Math.min(canvas.width, canvas.height) * (isMobile ? 0.15 : 0.2);
      
      // ä¸¤ä¸ªå°äººçš„ä¸­å¿ƒä½ç½®ï¼ˆå·¦å³å¯¹ç§°ï¼Œä½ç½®å¾€ä¸‹ç§»åŠ¨ï¼‰
      const leftX = centerX - scale * 1.5;
      const rightX = centerX + scale * 1.5;
      const baseY = centerY + scale * 0.8; // å¾€ä¸‹ç§»åŠ¨ä¸€äº›
      
      // è·³èˆåŠ¨ç”»ï¼šæ‰‹è‡‚å’Œè…¿ä¼šæ‘†åŠ¨
      const armSwing = Math.sin(frame * 0.1) * 0.3; // æ‰‹è‡‚æ‘†åŠ¨
      const legSwing = Math.sin(frame * 0.1 + Math.PI) * 0.2; // è…¿æ‘†åŠ¨
      const bodyTilt = Math.sin(frame * 0.08) * 0.1; // èº«ä½“å€¾æ–œ
      
      // ç»˜åˆ¶ä¸¤ä¸ªå°äºº
      for (let person = 0; person < 2; person++) {
        const personX = person === 0 ? leftX : rightX;
        const tilt = person === 0 ? bodyTilt : -bodyTilt;
        const arm = person === 0 ? armSwing : -armSwing;
        const leg = person === 0 ? legSwing : -legSwing;
        
        // å¤´éƒ¨ï¼ˆåœ†å½¢ï¼‰
        const headRadius = scale * 0.15;
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
          const x = personX + Math.cos(angle) * headRadius;
          const y = baseY - scale * 0.6 + Math.sin(angle) * headRadius;
          positions.push({ x, y });
        }
        
        // èº«ä½“ï¼ˆçŸ©å½¢ï¼‰
        const bodyWidth = scale * 0.2;
        const bodyHeight = scale * 0.4;
        for (let y = baseY - scale * 0.4; y < baseY; y += 2) {
          for (let x = personX - bodyWidth / 2; x < personX + bodyWidth / 2; x += 2) {
            positions.push({ x: x + tilt * 10, y });
          }
        }
        
        // å·¦æ‰‹è‡‚ï¼ˆå‘ä¸Šæ‘†åŠ¨ï¼‰
        const leftArmX = personX - bodyWidth / 2;
        const leftArmY = baseY - scale * 0.3;
        const leftArmLength = scale * 0.35;
        const leftArmAngle = Math.PI / 2 + arm;
        for (let i = 0; i < leftArmLength; i += 2) {
          const x = leftArmX + Math.cos(leftArmAngle) * i;
          const y = leftArmY + Math.sin(leftArmAngle) * i;
          positions.push({ x, y });
        }
        
        // å³æ‰‹è‡‚ï¼ˆå‘ä¸Šæ‘†åŠ¨ï¼‰
        const rightArmX = personX + bodyWidth / 2;
        const rightArmY = baseY - scale * 0.3;
        const rightArmLength = scale * 0.35;
        const rightArmAngle = Math.PI / 2 - arm;
        for (let i = 0; i < rightArmLength; i += 2) {
          const x = rightArmX + Math.cos(rightArmAngle) * i;
          const y = rightArmY + Math.sin(rightArmAngle) * i;
          positions.push({ x, y });
        }
        
        // å·¦è…¿ï¼ˆæ‘†åŠ¨ï¼‰
        const leftLegX = personX - bodyWidth / 3;
        const leftLegY = baseY;
        const leftLegLength = scale * 0.4;
        const leftLegAngle = Math.PI / 2 + leg;
        for (let i = 0; i < leftLegLength; i += 2) {
          const x = leftLegX + Math.cos(leftLegAngle) * i;
          const y = leftLegY + Math.sin(leftLegAngle) * i;
          positions.push({ x, y });
        }
        
        // å³è…¿ï¼ˆæ‘†åŠ¨ï¼‰
        const rightLegX = personX + bodyWidth / 3;
        const rightLegY = baseY;
        const rightLegLength = scale * 0.4;
        const rightLegAngle = Math.PI / 2 - leg;
        for (let i = 0; i < rightLegLength; i += 2) {
          const x = rightLegX + Math.cos(rightLegAngle) * i;
          const y = rightLegY + Math.sin(rightLegAngle) * i;
          positions.push({ x, y });
        }
      }
      
      return positions;
    }

    // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function detectGesture(landmarks) {
      const fingerTips = [8, 12, 16, 20];
      const fingerBases = [5, 9, 13, 17];
      const thumbTip = 4;
      const thumbBase = 2;

      let extendedFingers = [];
      let extendedCount = 0;

      // æ£€æµ‹æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦ä¼¸å±•ï¼ˆæŒ‡å°– y æ¯”æŒ‡æ ¹ y æ›´å°ï¼‰
      for (let i = 0; i < fingerTips.length; i++) {
        const isExtended = landmarks[fingerTips[i]].y < landmarks[fingerBases[i]].y;
        extendedFingers.push(isExtended);
        if (isExtended) extendedCount++;
      }

      // æ£€æµ‹æ‹‡æŒ‡æ˜¯å¦å®Œå…¨å±•å¼€
      // æ‹‡æŒ‡çš„æ£€æµ‹æ–¹å¼ä¸åŒï¼šéœ€è¦æ£€æŸ¥æ‹‡æŒ‡å°–ç›¸å¯¹äºæ‹‡æŒ‡æ ¹éƒ¨çš„xå’Œyåæ ‡
      // æ‹‡æŒ‡å®Œå…¨å±•å¼€ï¼šæ‹‡æŒ‡å°–xè·ç¦»æ‹‡æŒ‡æ ¹éƒ¨è¾ƒè¿œï¼ˆå¼ å¼€ï¼‰ï¼Œä¸”æ‹‡æŒ‡å°–yåæ ‡ä¸é«˜äºæ‹‡æŒ‡æ ¹éƒ¨å¤ªå¤šï¼ˆä¸å®Œå…¨å¼¯æ›²ï¼‰
      const thumbXDist = Math.abs(landmarks[thumbTip].x - landmarks[thumbBase].x);
      const thumbYDist = landmarks[thumbTip].y - landmarks[thumbBase].y;
      // æ‹‡æŒ‡å®Œå…¨å±•å¼€ï¼šxè·ç¦»å¤§ï¼ˆå¼ å¼€ï¼‰ï¼Œä¸”yè·ç¦»ä¸å¤ªå¤§ï¼ˆä¸å®Œå…¨å¼¯æ›²å‘ä¸‹ï¼‰
      // æ”¾å®½æ¡ä»¶ï¼Œæ›´å®¹æ˜“è¯†åˆ«
      const thumbFullyExtended = thumbXDist > 0.05 && thumbYDist < 0.08;
      
      // æ£€æµ‹æ‹‡æŒ‡å’Œé£ŸæŒ‡çš„è·ç¦»ï¼ˆç”¨äºåˆ¤æ–­æåˆï¼‰
      const thumbIndexDist = Math.sqrt(
        Math.pow(landmarks[thumbTip].x - landmarks[8].x, 2) +
          Math.pow(landmarks[thumbTip].y - landmarks[8].y, 2)
      );

      // è®¡ç®—æ€»å…±æœ‰å‡ ä¸ªæ‰‹æŒ‡å®Œå…¨å±•å¼€ï¼ˆåŒ…æ‹¬æ‹‡æŒ‡ï¼‰
      const totalExtendedCount = extendedCount + (thumbFullyExtended ? 1 : 0);

      // æåˆæ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»ï¼‰- å·²åœ¨ä¸Šé¢è®¡ç®—

      // åœ°çƒæ‰‹åŠ¿æ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼ŒåŒæ—¶ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡éƒ½å¼ å¼€ï¼‰- å·²åˆ é™¤ï¼Œæ”¹ä¸ºåŒæ‰‹åˆæ‹¢è§¦å‘

      // èƒœåˆ©æ‰‹åŠ¿æ£€æµ‹ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸å‡ºï¼Œå…¶ä»–æ”¶èµ·ï¼‰
      const isVictory = extendedFingers[0] && 
                        extendedFingers[1] && 
                        !extendedFingers[2] && 
                        !extendedFingers[3] &&
                        !thumbFullyExtended;

      // å…ˆæ£€æŸ¥4ä¸ªæ‰‹æŒ‡æ˜¯å¦éƒ½å¼ å¼€
      const allFourFingersExtended = extendedCount === 4 && 
                                      extendedFingers[0] && 
                                      extendedFingers[1] && 
                                      extendedFingers[2] && 
                                      extendedFingers[3];
      
      // æ¯” 4 æ‰‹åŠ¿æ£€æµ‹ï¼š4ä¸ªæ‰‹æŒ‡å®Œå…¨å±•å¼€ï¼Œæ‹‡æŒ‡ä¸å®Œå…¨å±•å¼€ï¼Œä¸”ä¸æ˜¯æåˆçŠ¶æ€
      // åŸºäºå®Œå…¨å±•å¼€çš„æ‰‹æŒ‡æ•°é‡ï¼š4ä¸ªæ‰‹æŒ‡ï¼ˆä¸åŒ…æ‹¬æ‹‡æŒ‡ï¼‰
      // å¿…é¡»ç¡®ä¿ä¸æ˜¯æåˆï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»ä¸èƒ½å¤ªè¿‘ï¼‰
      // ç¡®ä¿4ä¸ªæ‰‹æŒ‡éƒ½æ˜ç¡®å±•å¼€
      const isFour = extendedCount === 4 && 
                     extendedFingers[0] && 
                     extendedFingers[1] && 
                     extendedFingers[2] && 
                     extendedFingers[3] &&
                     !thumbFullyExtended &&
                     thumbIndexDist > 0.06; // ç¡®ä¿ä¸æ˜¯æåˆçŠ¶æ€

      // æ¯” 2 å’Œæ¯” 3 æ‰‹åŠ¿æ£€æµ‹ï¼šä½¿ç”¨ç²¾ç¡®çš„æ‰‹æŒ‡ä½ç½®æ£€æµ‹
      // æ£€æµ‹æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦æ˜æ˜¾ä¼¸å‡ºï¼ˆæŒ‡å°–æ˜æ˜¾é«˜äºæŒ‡æ ¹ï¼‰
      const indexExtended = landmarks[8].y < landmarks[5].y - 0.02; // é£ŸæŒ‡æ˜æ˜¾ä¼¸å‡º
      const middleExtended = landmarks[12].y < landmarks[9].y - 0.02; // ä¸­æŒ‡æ˜æ˜¾ä¼¸å‡º
      const ringExtended = landmarks[16].y < landmarks[13].y - 0.02; // æ— åæŒ‡æ˜æ˜¾ä¼¸å‡º
      const pinkyExtended = landmarks[20].y < landmarks[17].y - 0.02; // å°æŒ‡æ˜æ˜¾ä¼¸å‡º
      const ringNotExtended = landmarks[16].y >= landmarks[13].y; // æ— åæŒ‡æ”¶èµ·
      const pinkyNotExtended = landmarks[20].y >= landmarks[17].y; // å°æŒ‡æ”¶èµ·

      // æ¯” 2 æ‰‹åŠ¿æ£€æµ‹ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸å‡ºï¼Œå…¶ä»–æ”¶èµ·ï¼‰
      const isTwo = indexExtended && 
                    middleExtended && 
                    ringNotExtended && 
                    pinkyNotExtended;

      // æ¯” 3 æ‰‹åŠ¿æ£€æµ‹ï¼ˆé£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ä¼¸å‡ºï¼Œå°æŒ‡æ”¶èµ·ï¼‰
      const isThree = indexExtended && 
                      middleExtended && 
                      ringExtended && 
                      pinkyNotExtended;

      // æ¯” 1 æ‰‹åŠ¿æ£€æµ‹ï¼ˆåªä¼¸å‡ºé£ŸæŒ‡ï¼Œå…¶å®ƒæ‰‹æŒ‡æ”¶èµ·ï¼‰
      // å®¹å¿æ‹‡æŒ‡ä½ç½®ï¼Œä¸å¼ºåˆ¶è¦æ±‚æ‹‡æŒ‡å®Œå…¨æ”¶èµ·ï¼Œé¿å…è¿‡äºä¸¥æ ¼å¯¼è‡´è¯†åˆ«ä¸åˆ°
      const isOne = extendedFingers[0] && 
                    !extendedFingers[1] && 
                    !extendedFingers[2] && 
                    !extendedFingers[3];

      // æ¯” 6 æ‰‹åŠ¿æ£€æµ‹ï¼ˆæ‹‡æŒ‡ä¼¸å‡ºï¼Œå…¶ä»–4ä¸ªæ‰‹æŒ‡æ”¶èµ·ï¼Œå½¢æˆ"6"çš„æ‰‹åŠ¿ï¼‰
      // æˆ–è€…ï¼šæ‹‡æŒ‡+å°æŒ‡ä¼¸å‡ºï¼ˆç±»ä¼¼"6"çš„æ‰‹åŠ¿ï¼‰
      const isSix = thumbFullyExtended && 
                    !extendedFingers[0] && 
                    !extendedFingers[1] && 
                    !extendedFingers[2] && 
                    extendedFingers[3]; // æ‹‡æŒ‡+å°æŒ‡

      // æ¯” 8 æ‰‹åŠ¿æ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼Œå…¶ä»–æ‰‹æŒ‡å¯èƒ½å¼ å¼€ï¼Œç±»ä¼¼"8"çš„æ‰‹åŠ¿ï¼‰
      // æˆ–è€…ï¼šæ‹‡æŒ‡+ä¸­æŒ‡+æ— åæŒ‡ä¼¸å‡ºï¼ˆç±»ä¼¼"8"çš„æ‰‹åŠ¿ï¼‰
      const isEight = thumbFullyExtended && 
                      !extendedFingers[0] && 
                      extendedFingers[1] && 
                      extendedFingers[2] && 
                      !extendedFingers[3]; // æ‹‡æŒ‡+ä¸­æŒ‡+æ— åæŒ‡

      // æ‰‹åŠ¿æ£€æµ‹ä¼˜å…ˆçº§é¡ºåºï¼ˆå…ˆæ£€æµ‹ç‰¹æ®Šæ‰‹åŠ¿ï¼Œå†æ£€æµ‹é€šç”¨æ‰‹åŠ¿ï¼‰
      // 1. æ£€æµ‹æ•°å­—æ‰‹åŠ¿ï¼ˆæŒ‰æ•°å­—å¤§å°é¡ºåºï¼‰
      if (isOne) {
        return 'one';
      } else if (isTwo) {
        return 'two';
      } else if (isThree) {
        return 'three';
      } else if (isFour) {
        return 'four';
      } else if (isSix) {
        return 'six';
      } else if (isEight) {
        return 'eight';
      }
      // 3. æ£€æµ‹å…¶ä»–æ‰‹åŠ¿
      else if (isVictory) {
        return 'two'; // èƒœåˆ©æ‰‹åŠ¿ç­‰åŒäºæ¯”2
      } 
      // 4. æ£€æµ‹å¼ å¼€æ‰‹æŒï¼ˆ5ä¸ªæ‰‹æŒ‡ï¼‰- ç­‰åŒäº5
      else if (totalExtendedCount === 5) {
        // å¼ å¼€æ‰‹æŒï¼š5ä¸ªæ‰‹æŒ‡å®Œå…¨å±•å¼€ï¼ˆåŒ…æ‹¬æ‹‡æŒ‡ï¼‰
        // åŸºäºå®Œå…¨å±•å¼€çš„æ‰‹æŒ‡æ•°é‡ï¼š4ä¸ªæ‰‹æŒ‡ + æ‹‡æŒ‡ = 5ä¸ª
        return 'five'; // å¼ å¼€æ‰‹æŒç­‰åŒäº5
      } else if (extendedCount === 1 && landmarks[8].y < landmarks[5].y) {
        return 'pointing';
      } else if (extendedCount <= 1) {
        return 'closed';
      }

      return 'neutral';
    }

    // ç¨³å®šçš„æ‰‹åŠ¿è¯†åˆ«ï¼ˆä½¿ç”¨å†å²è®°å½•é¿å…é¢‘ç¹åˆ‡æ¢ï¼‰
    function getStableGesture(rawGesture) {
      // å¯¹äºéœ€è¦å¿«é€Ÿå“åº”çš„æ‰‹åŠ¿ï¼Œç›´æ¥è¿”å›ï¼Œä¸ä½¿ç”¨ç¨³å®šæ€§æœºåˆ¶
      const fastResponseGestures = ['one', 'four', 'open', 'five'];
      if (fastResponseGestures.includes(rawGesture)) {
        return rawGesture;
      }
      
      // æ·»åŠ åˆ°å†å²è®°å½•
      gestureHistory.push(rawGesture);
      if (gestureHistory.length > GESTURE_HISTORY_SIZE) {
        gestureHistory.shift(); // ç§»é™¤æœ€æ—§çš„è®°å½•
      }
      
      // å¦‚æœå†å²è®°å½•ä¸å¤Ÿï¼Œç›´æ¥è¿”å›åŸå§‹æ‰‹åŠ¿
      if (gestureHistory.length < 2) {
        return rawGesture;
      }
      
      // ç»Ÿè®¡æœ€è¿‘çš„æ‰‹åŠ¿å‡ºç°æ¬¡æ•°
      const recentGestures = gestureHistory.slice(-2); // åªçœ‹æœ€è¿‘2ä¸ª
      const gestureCounts = {};
      recentGestures.forEach(g => {
        gestureCounts[g] = (gestureCounts[g] || 0) + 1;
      });
      
      // æ‰¾å‡ºå‡ºç°æ¬¡æ•°æœ€å¤šçš„æ‰‹åŠ¿
      let maxCount = 0;
      let stableGesture = rawGesture;
      for (const [gesture, count] of Object.entries(gestureCounts)) {
        if (count > maxCount) {
          maxCount = count;
          stableGesture = gesture;
        }
      }
      
      // å¦‚æœç¨³å®šæ‰‹åŠ¿å‡ºç°2æ¬¡ï¼Œåˆ™ä½¿ç”¨ç¨³å®šæ‰‹åŠ¿ï¼ˆæ›´å®½æ¾çš„æ¡ä»¶ï¼‰
      if (maxCount >= 2) {
        return stableGesture;
      }
      
      return rawGesture;
    }

    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 2, // æ”¯æŒåŒæ‰‹æ£€æµ‹
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    hands.onResults((results) => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // å¤„ç†å¤šåªæ‰‹
        handsData = [];
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const rawGesture = detectGesture(landmarks);
          const gesture = getStableGesture(rawGesture); // ä½¿ç”¨ç¨³å®šçš„æ‰‹åŠ¿è¯†åˆ«
        const palm = landmarks[9];

          // è·å– handedness ä¿¡æ¯ï¼ˆåŒºåˆ†å·¦å³æ‰‹ï¼‰
          let handedness = 'Unknown';
          if (results.multiHandedness && results.multiHandedness[i]) {
            handedness = results.multiHandedness[i].categoryName; // 'Left' æˆ– 'Right'
          }

          // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨é€Ÿåº¦ï¼ˆä½¿ç”¨ç¬¬ä¸€åªæ‰‹çš„é€Ÿåº¦ï¼‰
          if (i === 0) {
            if (previousPalmX !== 0 && previousPalmY !== 0) {
              const dx = (palm.x - previousPalmX) * canvas.width;
              const dy = (palm.y - previousPalmY) * canvas.height;
              handSpeed = Math.min(1, Math.sqrt(dx * dx + dy * dy) / 100);
            }
            previousPalmX = palm.x;
            previousPalmY = palm.y;
          }
          
          const handInfo = {
          palmX: palm.x,
          palmY: palm.y,
            gesture: gesture,
            landmarks: landmarks,
            handIndex: i,
            handedness: handedness // æ·»åŠ å·¦å³æ‰‹ä¿¡æ¯
          };
          
          handsData.push(handInfo);
          
          // æ£€æµ‹æ‰‹åŠ¿åˆ‡æ¢ï¼Œè§¦å‘çˆ†ç‚¸æ•ˆæœï¼ˆåªå¯¹ç¬¬ä¸€åªæ‰‹ï¼‰
          if (i === 0) {
            const previousHand = previousHandsData.length > 0 ? previousHandsData[0] : previousHandData;
            if (previousHand && previousHand.gesture !== gesture) {
              if (gesture === 'two' || gesture === 'closed') {
                const px = palm.x * canvas.width;
                const py = palm.y * canvas.height;
                const colors = {
                  two: 'rgba(255, 200, 0, 0.8)',
                  closed: 'rgba(255, 100, 100, 0.8)',
                };
                explosions.push(new Explosion(px, py, colors[gesture] || 'rgba(255, 255, 255, 0.8)'));
              }
              
              // ä»èšæ‹¢æ‰‹åŠ¿ï¼ˆå¼ å¼€æ‰‹æŒï¼‰åˆ‡æ¢åˆ°æ’æ–¥æ‰‹åŠ¿ï¼ˆæ¡æ‹³ï¼‰æ—¶ï¼Œè¡°å‡ç²’å­é€Ÿåº¦
              // é˜²æ­¢é€Ÿåº¦ç´¯ç§¯å¯¼è‡´ç²’å­ä¹±è·‘
              if ((previousHand.gesture === 'open' || previousHand.gesture === 'five') && gesture === 'closed') {
                particles.forEach(p => {
                  // è¡°å‡é€Ÿåº¦ï¼Œé˜²æ­¢é€Ÿåº¦ç´¯ç§¯ï¼ˆæ›´æ¿€è¿›çš„è¡°å‡ï¼‰
                  p.vx *= 0.4;
                  p.vy *= 0.4;
                  // é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼ˆæ›´ä¸¥æ ¼ï¼‰
                  const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                  if (speed > 8) {
                    const scale = 8 / speed;
                    p.vx *= scale;
                    p.vy *= scale;
                  }
                });
              }
              
              // ä»æ’æ–¥æ‰‹åŠ¿åˆ‡æ¢åˆ°å…¶ä»–æ‰‹åŠ¿æ—¶ï¼Œä¹Ÿè¡°å‡é€Ÿåº¦ï¼Œé˜²æ­¢é€Ÿåº¦ç´¯ç§¯
              if (previousHand.gesture === 'closed' && gesture !== 'closed') {
                particles.forEach(p => {
                  // è½»å¾®è¡°å‡é€Ÿåº¦
                  p.vx *= 0.7;
                  p.vy *= 0.7;
                  // é™åˆ¶æœ€å¤§é€Ÿåº¦
                  const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                  if (speed > 12) {
                    const scale = 12 / speed;
                    p.vx *= scale;
                    p.vy *= scale;
                  }
                });
              }
              
              // ä»æ¯” 1 æ‰‹åŠ¿åˆ‡æ¢åˆ°å…¶ä»–æ‰‹åŠ¿æ—¶ï¼Œæ¸…é™¤æ–‡å­—ç›®æ ‡
              if (previousHand.gesture === 'one' && gesture !== 'one') {
                isFormingText = false;
                particles.forEach(p => {
                  p.targetX = null;
                  p.targetY = null;
                });
              }
            }
          }
        }
        
        // ä¿å­˜å½“å‰æ‰‹éƒ¨æ•°æ®ï¼ˆç”¨äºå…¼å®¹å•åªæ‰‹é€»è¾‘ï¼‰
        if (handsData.length > 0) {
          handData = handsData[0]; // ç¬¬ä¸€åªæ‰‹ç”¨äºå…¼å®¹
        } else {
          handData = null;
        }
        previousHandsData = handsData.slice(); // ä¿å­˜å†å²æ•°æ®
        previousHandData = handData; // å…¼å®¹å•åªæ‰‹é€»è¾‘

        // åŒæ‰‹åˆæ‹¢æ£€æµ‹ï¼šå·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1ï¼Œç²’å­æ±‡èšæˆçƒä½“
        // è¿›å…¥æ¡ä»¶ï¼šå·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1
        // é€€å‡ºå¼€å…³ï¼šåŒæ‰‹æ¡æ‹³ï¼ˆæ— è®ºè·ç¦»å¤šè¿œï¼‰
        let bothHandsClosed = false;
        let leftHandClosedRightHandOne = false;
        
        if (handsData.length === 2) {
          // æ£€æµ‹åˆ°ä¸¤åªæ‰‹
          const hand1 = handsData[0];
          const hand2 = handsData[1];
          
          // å°è¯•åŒºåˆ†å·¦å³æ‰‹
          let leftHand = hand1;
          let rightHand = hand2;
          if (hand1.handedness === 'Right' || hand2.handedness === 'Left') {
            leftHand = hand2;
            rightHand = hand1;
          } else if (hand1.handedness === 'Unknown' || hand2.handedness === 'Unknown') {
            // å¦‚æœæ— æ³•é€šè¿‡ handedness åŒºåˆ†ï¼Œé€šè¿‡ä½ç½®åˆ¤æ–­ï¼ˆå·¦æ‰‹é€šå¸¸åœ¨å·¦ä¾§ï¼‰
            if (hand1.palmX * canvas.width > hand2.palmX * canvas.width) {
              leftHand = hand2;
              rightHand = hand1;
            }
          }
          
          // æ£€æµ‹åŒæ‰‹æ˜¯å¦éƒ½æ˜¯æ¡æ‹³çŠ¶æ€
          bothHandsClosed = hand1.gesture === 'closed' && hand2.gesture === 'closed';
          
          // æ£€æµ‹ï¼šå·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1
          leftHandClosedRightHandOne = leftHand.gesture === 'closed' && rightHand.gesture === 'one';
          
          // è®¡ç®—å½“å‰åŒæ‰‹è·ç¦»ï¼ˆç”¨äºçƒä½“å¤§å°è®¡ç®—ï¼‰
          const hand1X = hand1.palmX * canvas.width;
          const hand1Y = hand1.palmY * canvas.height;
          const hand2X = hand2.palmX * canvas.width;
          const hand2Y = hand2.palmY * canvas.height;
          const currentDistance = Math.sqrt(
            Math.pow(hand1X - hand2X, 2) + Math.pow(hand1Y - hand2Y, 2)
          );
          previousHandsDistance = currentDistance;
        } else if (handsData.length === 1 && isHandsClosing) {
          // åªæ£€æµ‹åˆ°ä¸€åªæ‰‹ï¼Œé€€å‡ºåˆæ‹¢çŠ¶æ€
          isHandsClosing = false;
          isSphereMode = false;
          particles.forEach((p) => {
            p.sphereLat = null;
            p.sphereLon = null;
            p.targetX = null;
            p.targetY = null;
            p.targetIndex = null;
          });
        }
        
        // ä¼˜å…ˆæ£€æŸ¥ï¼šå¦‚æœåŒæ‰‹éƒ½æ˜¯æ¡æ‹³ï¼ˆæ— è®ºè·ç¦»å¤šè¿œï¼‰ï¼Œé€€å‡ºåˆæ‹¢çŠ¶æ€å¹¶è§¦å‘çˆ†ç‚¸
        // è¿™æ˜¯å”¯ä¸€çš„é€€å‡ºå¼€å…³
        if (bothHandsClosed && isHandsClosing) {
          // åœ¨çƒä½“ä¸­å¿ƒè§¦å‘å¼ºçƒˆçš„çˆ†ç‚¸æ•ˆæœ
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          // åˆ›å»ºå¤šä¸ªçˆ†ç‚¸æ•ˆæœå åŠ ï¼Œå¢å¼ºè§†è§‰æ•ˆæœ
          explosions.push(new Explosion(centerX, centerY, 'rgba(255, 100, 100, 0.9)', 2));
          explosions.push(new Explosion(centerX, centerY, 'rgba(255, 200, 100, 0.8)', 2));
          explosions.push(new Explosion(centerX, centerY, 'rgba(255, 150, 150, 0.7)', 2));
          
          // ç»™æ‰€æœ‰ç²’å­ä¸€ä¸ªå¼ºçƒˆçš„çˆ†ç‚¸åŠ›ï¼Œè®©å®ƒä»¬ä»ä¸­å¿ƒå‘å¤–æ•£å¼€
          particles.forEach((p) => {
            // æ¸…é™¤çƒä½“åæ ‡
            p.sphereLat = null;
            p.sphereLon = null;
            // æ¸…é™¤æ‰€æœ‰ç›®æ ‡ä½ç½®
            p.targetX = null;
            p.targetY = null;
            p.targetIndex = null;
            
            // è®¡ç®—ç²’å­åˆ°ä¸­å¿ƒçš„è·ç¦»å’Œæ–¹å‘
            const dx = p.x - centerX;
            const dy = p.y - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
              // ç»™ç²’å­ä¸€ä¸ªå¼ºçƒˆçš„å‘å¤–çˆ†ç‚¸åŠ›
              const force = 25 + Math.random() * 15; // æ›´å¼ºçš„çˆ†ç‚¸åŠ›
              p.vx = (dx / dist) * force + (Math.random() - 0.5) * 5;
              p.vy = (dy / dist) * force + (Math.random() - 0.5) * 5;
            } else {
              // å¦‚æœç²’å­å°±åœ¨ä¸­å¿ƒï¼Œéšæœºæ–¹å‘æ•£å¼€
              const angle = Math.random() * Math.PI * 2;
              const force = 25 + Math.random() * 15;
              p.vx = Math.cos(angle) * force;
              p.vy = Math.sin(angle) * force;
            }
            
            // ä¸ç«‹å³é‡ç½®ä½ç½®ï¼Œè®©ç²’å­ä»å½“å‰ä½ç½®çˆ†ç‚¸æ•£å¼€
            // è¿™æ ·çˆ†ç‚¸æ•ˆæœæ›´æ˜æ˜¾
          });
          
          // å»¶è¿Ÿé€€å‡ºåˆæ‹¢æ¨¡å¼ï¼Œè®©çˆ†ç‚¸æ•ˆæœå…ˆæ˜¾ç¤º
          setTimeout(() => {
            // è®©æ‰€æœ‰ç²’å­å›å½’åˆ°åŸæœ¬çš„éšæœºä½ç½®
            particles.forEach((p) => {
              // é‡ç½®ç²’å­åˆ°éšæœºä½ç½®
              p.x = Math.random() * canvas.width;
              p.y = Math.random() * canvas.height;
              // é‡ç½®é€Ÿåº¦
              p.vx = (Math.random() - 0.5) * 2;
              p.vy = (Math.random() - 0.5) * 2;
            });
          }, 1500); // 1.5ç§’åå›å½’
          
          // é€€å‡ºåˆæ‹¢æ¨¡å¼ï¼Œæ¢å¤æ‰€æœ‰æ‰‹åŠ¿
          isHandsClosing = false;
          isSphereMode = false;
          isFormingText = false;
          windEffectType = null;
          isDancing = false;
          textTargets = [];
          danceTargets = [];
          tornadoCenterX = 0;
          tornadoCenterY = 0;
          tornadoRotation = 0;
          stormActive = false;
          previousHandsDistance = Infinity;
        }
        // æ£€æµ‹ï¼šå·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1ï¼Œè§¦å‘æˆ–ä¿æŒçƒä½“æ¨¡å¼
        else if (leftHandClosedRightHandOne && !bothHandsClosed) {
            // è¿›å…¥æˆ–ä¿æŒåˆæ‹¢çŠ¶æ€
            if (!isHandsClosing) {
              isHandsClosing = true;
              handsClosingStartTime = Date.now();
            }
        }
        
        // å¦‚æœå·²ç»å¤„äºåˆæ‹¢çŠ¶æ€ï¼ŒæŒç»­æ›´æ–°çƒä½“å¤§å°ï¼ˆåŸºäºåŒæ‰‹è·ç¦»ï¼‰
        // æ— è®ºæ˜¯å¦æ»¡è¶³ leftHandClosedRightHandOneï¼Œåªè¦ isHandsClosing ä¸º true å°±æŒç»­æ›´æ–°
        if (isHandsClosing && handsData.length === 2 && !bothHandsClosed) {
              // è®¡ç®—å½“å‰åŒæ‰‹è·ç¦»
              const hand1 = handsData[0];
              const hand2 = handsData[1];
              const hand1X = hand1.palmX * canvas.width;
              const hand1Y = hand1.palmY * canvas.height;
              const hand2X = hand2.palmX * canvas.width;
              const hand2Y = hand2.palmY * canvas.height;
              const currentDistance = Math.sqrt(
                Math.pow(hand1X - hand2X, 2) + Math.pow(hand1Y - hand2Y, 2)
              );
              
              // è®¡ç®—çƒä½“å¤§å°ï¼šåŒæ‰‹è¿œç¦»å˜å¤§ï¼Œé è¿‘å˜å°
              const minRadius = 80;
              const maxRadius = 300;
              const baseDistance = 400; // 400åƒç´ ä½œä¸ºåŸºå‡†è·ç¦»
              const minDistance = 0;
              
              // è®¡ç®—å½’ä¸€åŒ–è·ç¦»ï¼ˆ0-1ï¼‰ï¼Œä½†å…è®¸è¶…å‡ºèŒƒå›´
              let normalizedDistance;
              if (baseDistance - minDistance > 0) {
                if (currentDistance <= baseDistance) {
                  normalizedDistance = Math.max(0, (currentDistance - minDistance) / (baseDistance - minDistance));
                } else {
                  // è¶…å‡ºèŒƒå›´æ—¶ï¼Œç»§ç»­æŒ‰æ¯”ä¾‹è®¡ç®—ï¼Œä½†é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
                  normalizedDistance = 1 + (currentDistance - baseDistance) / baseDistance;
                  normalizedDistance = Math.min(normalizedDistance, 2.5); // æœ€å¤§ä¸è¶…è¿‡2.5å€
                }
              } else {
                // é˜²æ­¢é™¤é›¶é”™è¯¯
                normalizedDistance = currentDistance / baseDistance;
              }
              
              // è®¡ç®—ç›®æ ‡åŠå¾„
              const targetRadius = minRadius + normalizedDistance * (maxRadius - minRadius) / 2;
              
              // ç›´æ¥ä½¿ç”¨ç›®æ ‡å€¼ï¼Œå®ç°é›¶å»¶è¿Ÿå“åº”
              sphereRadius = targetRadius;
              
              // çƒä½“ä¸­å¿ƒå›ºå®šåœ¨å±å¹•ä¸­å¿ƒ
              sphereCenterX = canvas.width / 2;
              sphereCenterY = canvas.height / 2;
              
              // è§¦å‘çƒä½“æ¨¡å¼
              if (!isSphereMode) {
                isSphereMode = true;
                isFormingText = false;
                windEffectType = null;
                fireEffectType = null;
                isDancing = false; // é€€å‡ºè·³èˆæ¨¡å¼
                textTargets = [];
                danceTargets = []; // æ¸…é™¤è·³èˆç›®æ ‡
                // æ¸…é™¤æ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®
                particles.forEach((p) => {
                  p.targetX = null;
                  p.targetY = null;
                  p.targetIndex = null;
                });
                // ä¸ºæ¯ä¸ªç²’å­åˆ†é…çƒé¢åæ ‡ï¼ˆå‡åŒ€åˆ†å¸ƒï¼‰
                const N = particles.length;
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                particles.forEach((p, i) => {
                  const t = N > 1 ? i / (N - 1) : 0.5;
                  const y = 1 - 2 * t; // -1..1
                  const r = Math.sqrt(1 - y * y);
                  const theta = goldenAngle * i;
                  p.sphereLat = Math.asin(y);
                  p.sphereLon = theta;
                });
              }
        }
        // æ³¨æ„ï¼šä¸å†æ»¡è¶³"å·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1"çš„æ¡ä»¶æ—¶ï¼Œä¸é€€å‡ºåˆæ‹¢çŠ¶æ€
        // åªæœ‰åŒæ‰‹æ¡æ‹³æ—¶æ‰ä¼šé€€å‡ºï¼ˆè¿™ä¸ªé€»è¾‘å·²ç»åœ¨ä¸Šé¢å¤„ç†äº†ï¼‰

        // æ£€æµ‹åˆ°æ¯” 4 æ‰‹åŠ¿æ—¶ï¼Œç”Ÿæˆè·³èˆå°äººç²’å­ä½ç½®ï¼ˆéçƒä½“æ¨¡å¼ä¸”éåŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹æ‰ç”Ÿæ•ˆï¼‰
        // ä½¿ç”¨ç¬¬ä¸€åªæ‰‹çš„æ‰‹åŠ¿ï¼Œä¸”å¿…é¡»æ˜¯å•æ‰‹æ‰èƒ½è§¦å‘
        if (!isSphereMode && !isHandsClosing && handsData.length === 1 && handsData[0].gesture === 'four') {
          // åªåœ¨ç¬¬ä¸€æ¬¡è¿›å…¥è·³èˆæ¨¡å¼æ—¶åˆ†é…ç²’å­ï¼Œé¿å…é‡å¤åˆ†é…å¯¼è‡´æ··ä¹±
          if (!isDancing) {
            isDancing = true;
            danceFrame = 0;
            // ç”Ÿæˆè·³èˆå°äººä½ç½®ï¼ˆä¼šæŒç»­æ›´æ–°åŠ¨ç”»ï¼‰
            danceTargets = generateDancingFigures(danceFrame);

            // åªç”¨ä¸€éƒ¨åˆ†ç²’å­æ‹¼å°äººï¼šé€‰æ‹©é è¿‘å±å¹•ä¸­å¿ƒçš„ç²’å­
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // å¤åˆ¶ä¸€ä»½å¸¦è·ç¦»ä¿¡æ¯çš„ç²’å­æ•°ç»„
            const particlesWithDist = particles.map((p, idx) => {
              const dx = p.x - centerX;
              const dy = p.y - centerY;
              return { p, idx, dist: Math.sqrt(dx * dx + dy * dy) };
            });

            // æŒ‰è·ç¦»ä»è¿‘åˆ°è¿œæ’åº
            particlesWithDist.sort((a, b) => a.dist - b.dist);

            // å‚ä¸æ‹¼å°äººçš„ç²’å­æ•°é‡ï¼ˆä¸è¶…è¿‡å°äººç‚¹æ•°çš„ 70%ï¼Œä¹Ÿä¸è¶…è¿‡æ€»ç²’å­çš„ 70%ï¼‰
            const maxDanceParticles = Math.min(
              Math.floor(particles.length * 0.7),
              Math.floor(danceTargets.length * 0.7)
            );

            // å…ˆæ¸…ç©ºæ‰€æœ‰ç²’å­çš„ target
            particles.forEach((particle) => {
              particle.targetX = null;
              particle.targetY = null;
              particle.targetIndex = null;
            });

            // è®©è·ç¦»ä¸­å¿ƒæœ€è¿‘çš„ä¸€éƒ¨åˆ†ç²’å­å‚ä¸æ‹¼å°äºº
            for (let i = 0; i < maxDanceParticles; i++) {
              const { p } = particlesWithDist[i];
              const targetIndex = Math.floor(
                (i / Math.max(1, maxDanceParticles - 1)) * (danceTargets.length - 1)
              );
              p.targetX = danceTargets[targetIndex].x;
              p.targetY = danceTargets[targetIndex].y;
              p.targetIndex = targetIndex; // ä¿å­˜ç´¢å¼•ç”¨äºåŠ¨ç”»æ›´æ–°
            }
          }
        } else if (!isHandsClosing && handsData.length > 0 && handsData[0].gesture !== 'four' && isDancing) {
          // ä»æ¯” 4 æ‰‹åŠ¿åˆ‡æ¢åˆ°å…¶ä»–æ‰‹åŠ¿æ—¶ï¼Œåªåœ¨æ£€æµ‹åˆ°æ˜ç¡®çš„é'four'æ‰‹åŠ¿æ—¶æ‰æ¸…é™¤
          // é¿å…å› ä¸ºæ‰‹åŠ¿è¯†åˆ«ä¸ç¨³å®šå¯¼è‡´é¢‘ç¹åˆ‡æ¢
          // åªåœ¨æ£€æµ‹åˆ°æ˜ç¡®çš„é'four'æ‰‹åŠ¿ï¼ˆå¦‚'closed'ã€'open'ã€'one'ç­‰ï¼‰æ—¶æ‰æ¸…é™¤
          const currentGesture = handsData[0].gesture;
          if (currentGesture === 'closed' || currentGesture === 'open' || currentGesture === 'five' || currentGesture === 'one' || 
              currentGesture === 'two' || currentGesture === 'pointing') {
            isDancing = false;
            particles.forEach(p => {
              p.targetX = null;
              p.targetY = null;
              p.targetIndex = null;
            });
          }
          // å¦‚æœæ˜¯'neutral'æˆ–å…¶ä»–ä¸ç¡®å®šçš„æ‰‹åŠ¿ï¼Œä¿æŒè·³èˆæ¨¡å¼
        }
        
        // å¦‚æœè¿›å…¥åŒæ‰‹åˆæ‹¢æ¨¡å¼ï¼Œå¼ºåˆ¶æ¸…é™¤è·³èˆã€æ–‡å­—å½¢æˆå’Œå½¢çŠ¶å½¢æˆçŠ¶æ€
        if (isHandsClosing) {
          if (isDancing) {
            isDancing = false;
            danceTargets = [];
            particles.forEach(p => {
              p.targetX = null;
              p.targetY = null;
              p.targetIndex = null;
            });
          }
          if (isFormingText) {
            isFormingText = false;
            textTargets = [];
            particles.forEach(p => {
              p.targetX = null;
              p.targetY = null;
            });
          }
          if (windEffectType) {
            windEffectType = null;
            tornadoCenterX = 0;
            tornadoCenterY = 0;
            tornadoRotation = 0;
            stormActive = false;
          }
          if (fireEffectType) {
            fireEffectType = null;
            fireballCenterX = 0;
            fireballCenterY = 0;
            fireballIntensity = 0;
            explosionActive = false;
            phoenixTrail = [];
          }
          if (waterEffectType) {
            waterEffectType = null;
            rippleWaves = [];
            rainParticles = [];
            splitStreamCenterX = 0;
            splitStreamCenterY = 0;
          }
        }

        // æ£€æµ‹åŒæ‰‹ç»„åˆæ‰‹åŠ¿ï¼šå·¦æ‰‹1 + å³æ‰‹1-5ï¼Œè§¦å‘ä¸åŒé£ç³»æ•ˆæœ
        // åªæœ‰åœ¨éçƒä½“æ¨¡å¼ä¸”éåŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹æ‰ç”Ÿæ•ˆ
        if (!isSphereMode && !isHandsClosing && handsData.length === 2) {
          const leftHand = handsData.find(h => h.handedness === 'Left') || handsData[0];
          const rightHand = handsData.find(h => h.handedness === 'Right') || handsData[1];
          
          // å¦‚æœæ— æ³•é€šè¿‡ handedness åŒºåˆ†ï¼Œå°è¯•é€šè¿‡ä½ç½®åˆ¤æ–­ï¼ˆå·¦æ‰‹é€šå¸¸åœ¨å·¦ä¾§ï¼‰
          let actualLeftHand = leftHand;
          let actualRightHand = rightHand;
          if (leftHand.handedness === 'Unknown' || rightHand.handedness === 'Unknown') {
            // é€šè¿‡xåæ ‡åˆ¤æ–­ï¼šå·¦æ‰‹åœ¨å·¦ä¾§ï¼ˆxè¾ƒå°ï¼‰ï¼Œå³æ‰‹åœ¨å³ä¾§ï¼ˆxè¾ƒå¤§ï¼‰
            if (leftHand.palmX * canvas.width > rightHand.palmX * canvas.width) {
              actualLeftHand = rightHand;
              actualRightHand = leftHand;
            }
          }
          
          // æ£€æµ‹å·¦æ‰‹æ˜¯å¦ä¸º'one'ï¼Œå³æ‰‹æ˜¯å¦ä¸ºæŒ‡å®šæ‰‹åŠ¿
          if (actualLeftHand.gesture === 'one') {
            let targetWindEffect = null;
            if (actualRightHand.gesture === 'one') {
              targetWindEffect = 'tornado'; // å·¦1å³1 - æ—‹é£ç”Ÿæˆ
            } else if (actualRightHand.gesture === 'two') {
              // å·¦1å³2 æ”¹ä¸ºæ°´ç³»æ•ˆæœï¼ˆæ°´æ³¢æ¶Ÿæ¼ªï¼‰ï¼Œä¸å†ä½¿ç”¨é£ç³»
              // targetWindEffect = 'blow'; // å·¦1å³2 - ç²’å­å¹æ•£ï¼ˆå·²ç§»é™¤ï¼‰
              // æ°´ç³»æ•ˆæœåœ¨ä¸‹é¢å•ç‹¬å¤„ç†
            } else if (actualRightHand.gesture === 'four') {
              targetWindEffect = 'distortion'; // å·¦1å³4 - æ°”æµæŠ˜å°„
            } else if (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five') {
              targetWindEffect = 'storm'; // å·¦1å³5 - æš´é£æ¨¡å¼
            }
            
            // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„é£ç³»æ•ˆæœç»„åˆ
            if (targetWindEffect && windEffectType !== targetWindEffect) {
              windEffectType = targetWindEffect;
              isFormingText = false; // ç¦ç”¨æ–‡å­—å½¢æˆ
              isDancing = false; // ç¦ç”¨è·³èˆ
              textTargets = [];
              danceTargets = [];
              
              // åˆå§‹åŒ–é£ç³»æ•ˆæœ
              if (targetWindEffect === 'tornado') {
                tornadoRotation = 0;
              } else if (targetWindEffect === 'storm') {
                stormActive = true;
                stormStartTime = Date.now();
              }
            }
            
            // å·¦1å³2 å·²åˆ é™¤ï¼Œä¼˜å…ˆä¿ç•™å·¦5å³2ï¼ˆæ°´æµåˆ†è£‚ï¼‰æ•ˆæœ
          } else if (actualLeftHand.gesture !== 'one') {
            // å¦‚æœå·¦æ‰‹ä¸æ˜¯'one'ï¼Œæ¸…é™¤é£ç³»æ•ˆæœ
            if (windEffectType) {
              windEffectType = null;
              tornadoCenterX = 0;
              tornadoCenterY = 0;
              tornadoRotation = 0;
              stormActive = false;
            }
          }
          
          // æ£€æµ‹å·¦æ‰‹æ˜¯å¦ä¸º'closed'ï¼ˆæ¡æ‹³ï¼‰ï¼Œå³æ‰‹æ˜¯å¦ä¸ºæŒ‡å®šæ‰‹åŠ¿ï¼ˆæ°´ç³»æ•ˆæœï¼‰
          if (actualLeftHand.gesture === 'closed') {
            let targetWaterEffect = null;
            if (actualRightHand.gesture === 'two') {
              targetWaterEffect = 'rain'; // æ¡æ‹³+å³æ‰‹2 - é›¨æ»´ç”Ÿæˆ
            }
            
            // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„æ°´ç³»æ•ˆæœç»„åˆ
            if (targetWaterEffect && waterEffectType !== targetWaterEffect) {
              waterEffectType = targetWaterEffect;
              isFormingText = false;
              isDancing = false;
              windEffectType = null;
              fireEffectType = null;
              spaceEffectType = null;
              textTargets = [];
              danceTargets = [];
              
              // åˆå§‹åŒ–æ°´ç³»æ•ˆæœ
              if (targetWaterEffect === 'rain') {
                rainParticles = [];
              }
            }
          } else if (actualLeftHand.gesture !== 'closed') {
            // å¦‚æœå·¦æ‰‹ä¸æ˜¯'closed'ï¼ˆæ¡æ‹³ï¼‰ï¼Œæ¸…é™¤æ°´ç³»æ•ˆæœï¼ˆä»…æ¸…é™¤æ¡æ‹³+å³æ‰‹2çš„æ•ˆæœï¼‰
            if (waterEffectType === 'rain') {
              waterEffectType = null;
              rainParticles = [];
            }
          }
          
          // æ£€æµ‹å·¦æ‰‹æ˜¯å¦ä¸º'five'æˆ–'open'ï¼Œå³æ‰‹æ˜¯å¦ä¸ºæŒ‡å®šæ‰‹åŠ¿ï¼ˆæ°´ç³»æ•ˆæœï¼‰
          if (actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') {
            let targetWaterEffect = null;
            if (actualRightHand.gesture === 'two') {
              targetWaterEffect = 'split'; // å·¦5å³2 - æ°´æµåˆ†è£‚
            }
            
            // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„æ°´ç³»æ•ˆæœç»„åˆ
            if (targetWaterEffect && waterEffectType !== targetWaterEffect) {
              waterEffectType = targetWaterEffect;
              isFormingText = false;
              isDancing = false;
              windEffectType = null;
              fireEffectType = null;
              spaceEffectType = null;
              textTargets = [];
              danceTargets = [];
              
              // åˆå§‹åŒ–æ°´ç³»æ•ˆæœ
              if (targetWaterEffect === 'split') {
                splitStreamCenterX = actualRightHand.palmX * canvas.width;
                splitStreamCenterY = actualRightHand.palmY * canvas.height;
                splitStreamAngle = 0;
              }
            }
          } else if (actualLeftHand.gesture !== 'open' && actualLeftHand.gesture !== 'five') {
            // å¦‚æœå·¦æ‰‹ä¸æ˜¯'open'æˆ–'five'ï¼Œæ¸…é™¤æ°´ç³»æ•ˆæœï¼ˆä»…æ¸…é™¤å·¦5å³2çš„æ•ˆæœï¼‰
            if (waterEffectType === 'split') {
              waterEffectType = null;
              splitStreamCenterX = 0;
              splitStreamCenterY = 0;
            }
          }
          
          // æ£€æµ‹å·¦æ‰‹æ˜¯å¦ä¸º'two'ï¼Œå³æ‰‹æ˜¯å¦ä¸ºæŒ‡å®šæ‰‹åŠ¿ï¼ˆç«ç³»æ•ˆæœï¼‰
          if (actualLeftHand.gesture === 'two') {
            let targetFireEffect = null;
            if (actualRightHand.gesture === 'one') {
              targetFireEffect = 'fireball'; // å·¦2å³1 - ç«çƒå‡èš
            } else if (actualRightHand.gesture === 'two') {
              targetFireEffect = 'flame'; // å·¦2å³2 - ç«ç„°å–·å°„
            } else if (actualRightHand.gesture === 'four') {
              targetFireEffect = 'explosion'; // å·¦2å³4 - ç«ç„°çˆ†è£‚
            } else if (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five') {
              targetFireEffect = 'phoenix'; // å·¦2å³5 - ç«ç„°å‡¤å‡°
            }
            
            // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„ç«ç³»æ•ˆæœç»„åˆ
            if (targetFireEffect && fireEffectType !== targetFireEffect) {
              fireEffectType = targetFireEffect;
              isFormingText = false; // ç¦ç”¨æ–‡å­—å½¢æˆ
              isDancing = false; // ç¦ç”¨è·³èˆ
              windEffectType = null; // ç¦ç”¨é£ç³»æ•ˆæœ
              textTargets = [];
              danceTargets = [];
              
              // åˆå§‹åŒ–ç«ç³»æ•ˆæœ
              if (targetFireEffect === 'fireball') {
                fireballIntensity = 0;
              } else if (targetFireEffect === 'explosion') {
                // æ£€æµ‹å³æ‰‹æ”¶æ‹³â†’å¼ å¼€
                if (previousRightHandGesture === 'closed' && (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five')) {
                  explosionActive = true;
                  explosionStartTime = Date.now();
                }
              } else if (targetFireEffect === 'phoenix') {
                phoenixTrail = [];
                if (actualRightHand) {
                  phoenixPosition.x = actualRightHand.palmX * canvas.width;
                  phoenixPosition.y = actualRightHand.palmY * canvas.height;
                }
              }
            }
            
            // æ£€æµ‹å³æ‰‹æ”¶æ‹³â†’å¼ å¼€ï¼ˆç”¨äºçˆ†ç‚¸æ•ˆæœï¼‰
            if (targetFireEffect === 'explosion' && previousRightHandGesture === 'closed' && (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five')) {
              explosionActive = true;
              explosionStartTime = Date.now();
            }
            
            // æ›´æ–°ä¸Šä¸€å¸§å³æ‰‹æ‰‹åŠ¿
            previousRightHandGesture = actualRightHand.gesture;
          } else if (actualLeftHand.gesture !== 'two') {
            // å¦‚æœå·¦æ‰‹ä¸æ˜¯'two'ï¼Œæ¸…é™¤ç«ç³»æ•ˆæœ
            if (fireEffectType) {
              fireEffectType = null;
              fireballCenterX = 0;
              fireballCenterY = 0;
              fireballIntensity = 0;
              explosionActive = false;
              phoenixTrail = [];
            }
            previousRightHandGesture = null;
          }
          
          // æ£€æµ‹å·¦æ‰‹æ˜¯å¦ä¸º'four'ï¼Œå³æ‰‹æ˜¯å¦ä¸ºæŒ‡å®šæ‰‹åŠ¿ï¼ˆç©ºé—´æ‰­æ›²æ•ˆæœï¼‰
          if (actualLeftHand.gesture === 'four') {
            let targetSpaceEffect = null;
            if (actualRightHand.gesture === 'one') {
              targetSpaceEffect = 'blackhole'; // å·¦4å³1 - è™«æ´å¸å¼•
            } else if (actualRightHand.gesture === 'two') {
              // å·¦4å³2 æ”¹ä¸ºæ°´ç³»æ•ˆæœï¼ˆç²’å­å‡ç»“ï¼‰ï¼Œä¸å†ä½¿ç”¨ç©ºé—´æ‰­æ›²
              // targetSpaceEffect = 'portal'; // å·¦4å³2 - ç©ºé—´é—¨ï¼ˆå·²ç§»é™¤ï¼‰
              // æ°´ç³»æ•ˆæœåœ¨ä¸‹é¢å•ç‹¬å¤„ç†
            } else if (actualRightHand.gesture === 'four') {
              targetSpaceEffect = 'freeze'; // å·¦4å³4 - ç²’å­å†»ç»“
            } else if (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five') {
              targetSpaceEffect = 'rewind'; // å·¦4å³5 - æ—¶é—´å€’æµ
            }
            
            // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„ç©ºé—´æ‰­æ›²æ•ˆæœç»„åˆ
            if (targetSpaceEffect && spaceEffectType !== targetSpaceEffect) {
              spaceEffectType = targetSpaceEffect;
              isFormingText = false; // ç¦ç”¨æ–‡å­—å½¢æˆ
              isDancing = false; // ç¦ç”¨è·³èˆ
              windEffectType = null; // ç¦ç”¨é£ç³»æ•ˆæœ
              fireEffectType = null; // ç¦ç”¨ç«ç³»æ•ˆæœ
              waterEffectType = null; // ç¦ç”¨æ°´ç³»æ•ˆæœ
              textTargets = [];
              danceTargets = [];
              
              // åˆå§‹åŒ–ç©ºé—´æ‰­æ›²æ•ˆæœ
              if (targetSpaceEffect === 'blackhole') {
                blackHoleIntensity = 0;
              } else if (targetSpaceEffect === 'freeze') {
                particlesFrozen = false;
              } else if (targetSpaceEffect === 'rewind') {
                rewindActive = false;
                rightHandRotationAngle = 0;
                previousRightHandPosition = {
                  x: actualRightHand.palmX * canvas.width,
                  y: actualRightHand.palmY * canvas.height
                };
                // åˆå§‹åŒ–æ‰€æœ‰ç²’å­çš„å†å²è®°å½•
                particles.forEach(p => {
                  if (!p.history) p.history = [];
                });
              }
            }
            
            // æ£€æµ‹å·¦4å³2 - ç²’å­å‡ç»“ï¼ˆæ°´ç³»æ•ˆæœï¼‰
            if (actualRightHand.gesture === 'two') {
              let targetWaterEffect = 'condense';
              if (waterEffectType !== targetWaterEffect) {
                waterEffectType = targetWaterEffect;
                isFormingText = false;
                isDancing = false;
                windEffectType = null;
                fireEffectType = null;
                spaceEffectType = null; // ç¦ç”¨ç©ºé—´æ‰­æ›²æ•ˆæœ
                textTargets = [];
                danceTargets = [];
              }
            }
            
            // æ›´æ–°å³æ‰‹ä½ç½®ï¼ˆç”¨äºæ—¶é—´å€’æµæ£€æµ‹ï¼‰
            if (targetSpaceEffect === 'rewind') {
              const currentRightHandX = actualRightHand.palmX * canvas.width;
              const currentRightHandY = actualRightHand.palmY * canvas.height;
              const dx = currentRightHandX - previousRightHandPosition.x;
              const dy = currentRightHandY - previousRightHandPosition.y;
              rightHandRotationAngle = Math.atan2(dy, dx);
              previousRightHandPosition = { x: currentRightHandX, y: currentRightHandY };
            }
          } else if (actualLeftHand.gesture !== 'four') {
            // å¦‚æœå·¦æ‰‹ä¸æ˜¯'four'ï¼Œæ¸…é™¤ç©ºé—´æ‰­æ›²æ•ˆæœå’Œæ°´ç³»æ•ˆæœ
            if (spaceEffectType) {
              spaceEffectType = null;
              blackHoleX = 0;
              blackHoleY = 0;
              blackHoleIntensity = 0;
              portalCenterX = 0;
              portalCenterY = 0;
              portalRadius = 0;
              particlesFrozen = false;
              rewindActive = false;
              // æ¸…é™¤ç²’å­å†å²è®°å½•
              particles.forEach(p => {
                if (p.history) p.history = [];
              });
            }
            if (waterEffectType === 'condense') {
              waterEffectType = null;
            }
          }
          
          // æ£€æµ‹é«˜çº§ç»„åˆæ‰‹åŠ¿æ•ˆæœï¼ˆå³æ‰‹Xï¼Œå·¦æ‰‹Yï¼‰
          // æ³¨æ„ï¼šè¦é¿å…ä¸æ°´ç³»æ•ˆæœï¼ˆå·¦æ‰‹X + å³æ‰‹2ï¼‰å†²çª
          // æ°´ç³»æ•ˆæœä¼˜å…ˆçº§æ›´é«˜ï¼Œæ‰€ä»¥é«˜çº§ç»„åˆæ•ˆæœåªåœ¨æ²¡æœ‰æ°´ç³»æ•ˆæœå†²çªæ—¶æ‰æ¿€æ´»
          let targetAdvancedEffect = null;
          
          // æ£€æŸ¥æ˜¯å¦æœ‰æ°´ç³»æ•ˆæœå†²çª
          const hasWaterConflict = (
            (actualLeftHand.gesture === 'closed' && actualRightHand.gesture === 'two') || // æ¡æ‹³+å³æ‰‹2 = é›¨æ»´ç”Ÿæˆ
            (actualLeftHand.gesture === 'four' && actualRightHand.gesture === 'two') || // å·¦4å³2 = ç²’å­å‡ç»“
            ((actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') && actualRightHand.gesture === 'two') // å·¦5å³2 = æ°´æµåˆ†è£‚
          );
          
          // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–åŸºç¡€æ•ˆæœå†²çªï¼ˆé£ç³»ã€ç«ç³»ã€ç©ºé—´ï¼‰
          const hasWindConflict = (
            (actualLeftHand.gesture === 'one' && actualRightHand.gesture === 'one') || // å·¦1å³1 = æ—‹é£ç”Ÿæˆ
            (actualLeftHand.gesture === 'one' && actualRightHand.gesture === 'four') || // å·¦1å³4 = æ°”æµæŠ˜å°„
            (actualLeftHand.gesture === 'one' && (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five')) // å·¦1å³5 = æš´é£æ¨¡å¼
          );
          
          const hasFireConflict = (
            (actualLeftHand.gesture === 'two' && actualRightHand.gesture === 'one') || // å·¦2å³1 = ç«çƒå‡èš
            (actualLeftHand.gesture === 'two' && actualRightHand.gesture === 'two') || // å·¦2å³2 = ç«ç„°å–·å°„
            (actualLeftHand.gesture === 'two' && actualRightHand.gesture === 'four') || // å·¦2å³4 = ç«ç„°çˆ†è£‚
            (actualLeftHand.gesture === 'two' && (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five')) // å·¦2å³5 = ç«ç„°å‡¤å‡°
          );
          
          const hasSpaceConflict = (
            (actualLeftHand.gesture === 'four' && actualRightHand.gesture === 'one') || // å·¦4å³1 = è™«æ´å¸å¼•
            (actualLeftHand.gesture === 'four' && actualRightHand.gesture === 'four') || // å·¦4å³4 = ç²’å­å†»ç»“
            (actualLeftHand.gesture === 'four' && (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five')) // å·¦4å³5 = æ—¶é—´å€’æµ
          );
          
          // åªæœ‰åœ¨æ²¡æœ‰åŸºç¡€æ•ˆæœå†²çªæ—¶æ‰æ£€æµ‹é«˜çº§ç»„åˆæ•ˆæœ
          if (!hasWaterConflict && !hasWindConflict && !hasFireConflict && !hasSpaceConflict) {
            // å³æ‰‹1ç³»åˆ—
            if (actualRightHand.gesture === 'one') {
              // å³1å·¦2 ä¸ å·¦2å³1ï¼ˆç«çƒå‡èšï¼‰å†²çªï¼Œå·²åˆ é™¤
              // å³1å·¦4 ä¸ å·¦4å³1ï¼ˆè™«æ´å¸å¼•ï¼‰å†²çªï¼Œå·²åˆ é™¤
              if (actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') {
                targetAdvancedEffect = 'gravityring'; // å³æ‰‹1ï¼Œå·¦æ‰‹5 - é‡åŠ›æ‰­æ›²ç¯
              }
            }
            // å³æ‰‹2ç³»åˆ—
            else if (actualRightHand.gesture === 'two') {
              // å³2å·¦1 ä¸ å·¦1å³2ï¼ˆæ°´æ³¢æ¶Ÿæ¼ªï¼‰å†²çªï¼Œå·²åˆ é™¤
              // å³2å·¦2 ä¸ å·¦2å³2ï¼ˆç«ç„°å–·å°„ï¼‰å†²çªï¼Œå·²åˆ é™¤
              // å³2å·¦4 æ”¹ä¸ºå³æ‰‹2å·¦æ‰‹4ï¼ˆæ—¶ç©ºèºæ—‹æªï¼‰ï¼Œåˆ é™¤é‡å¤çš„å³2å·¦4
              if (actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') {
                targetAdvancedEffect = 'gravityarc'; // å³æ‰‹2ï¼Œå·¦æ‰‹5 - é‡åŠ›æ°´å¼§
              }
            }
            
            // å³æ‰‹2ï¼Œå·¦æ‰‹4 - æ—¶ç©ºèºæ—‹æªï¼ˆæ”¹ä¸ºè¿™ä¸ªç»„åˆï¼‰
            if (actualRightHand.gesture === 'two' && actualLeftHand.gesture === 'four') {
              targetAdvancedEffect = 'spiralbeam'; // å³æ‰‹2ï¼Œå·¦æ‰‹4 - æ—¶ç©ºèºæ—‹æª
            }
            // å³æ‰‹4ç³»åˆ—
            else if (actualRightHand.gesture === 'four') {
              if (actualLeftHand.gesture === 'one') {
                targetAdvancedEffect = 'storm'; // å³æ‰‹4ï¼Œå·¦æ‰‹1 - é›·æš´å¼•å¯¼
              }
              // å³4å·¦2 ä¸ å·¦2å³4ï¼ˆç«ç„°çˆ†è£‚ï¼‰å†²çªï¼Œå·²åˆ é™¤
              if (actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') {
                targetAdvancedEffect = 'rainbowcurl'; // å³æ‰‹4ï¼Œå·¦æ‰‹5 - é›¶é‡åŠ›å½©è‰²å¼§çº¿
              }
            }
            // å³æ‰‹5ç³»åˆ—
            else if (actualRightHand.gesture === 'open' || actualRightHand.gesture === 'five') {
              // å³5å·¦1 ä¸ å·¦1å³5ï¼ˆæš´é£æ¨¡å¼ï¼‰å†²çªï¼Œå·²åˆ é™¤
              // å³5å·¦2 ä¸ å·¦2å³5ï¼ˆç«ç„°å‡¤å‡°ï¼‰å†²çªï¼Œå·²åˆ é™¤
              // å³5å·¦4 ä¸ å·¦4å³5ï¼ˆæ—¶é—´å€’æµï¼‰å†²çªï¼Œå·²åˆ é™¤
              if (actualLeftHand.gesture === 'open' || actualLeftHand.gesture === 'five') {
                targetAdvancedEffect = 'lightning'; // å³æ‰‹5ï¼Œå·¦æ‰‹5 - åŒæ‰‹é›·ç”µçƒ
              }
            }
          }
          
          // å¦‚æœæ£€æµ‹åˆ°æœ‰æ•ˆçš„é«˜çº§ç»„åˆæ•ˆæœ
          if (targetAdvancedEffect && advancedEffectType !== targetAdvancedEffect) {
            advancedEffectType = targetAdvancedEffect;
            isFormingText = false;
            isDancing = false;
            windEffectType = null;
            fireEffectType = null;
            waterEffectType = null;
            spaceEffectType = null;
            textTargets = [];
            danceTargets = [];
            
            // åˆå§‹åŒ–é«˜çº§ç»„åˆæ•ˆæœ
            if (targetAdvancedEffect === 'gravityring') {
              gravityRingRadius = 0;
              gravityRingAngle = 0;
            } else if (targetAdvancedEffect === 'spiralbeam') {
              spiralBeamRotation = 0;
            } else if (targetAdvancedEffect === 'gravityarc') {
              gravityArcGravity = { x: 0, y: 1 };
            } else if (targetAdvancedEffect === 'storm') {
              stormClouds = [];
              lightningActive = false;
            } else if (targetAdvancedEffect === 'rainbowcurl') {
              rainbowCurlParticles = [];
            } else if (targetAdvancedEffect === 'lightning') {
              lightningBoltActive = false;
              lightningBoltTime = 0;
              lightningBoltPath = [];
            }
          } else if (!targetAdvancedEffect && advancedEffectType) {
            // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°é«˜çº§ç»„åˆæ•ˆæœï¼Œæ¸…é™¤
            advancedEffectType = null;
            serpentChain1 = [];
            serpentChain2 = [];
            spaceTearPath = [];
            stormClouds = [];
            rainbowCurlParticles = [];
          }
        } else if (handsData.length !== 2) {
          // å¦‚æœä¸å†æ£€æµ‹åˆ°ä¸¤åªæ‰‹ï¼Œæ¸…é™¤æ‰€æœ‰æ•ˆæœ
          if (windEffectType) {
            windEffectType = null;
            tornadoCenterX = 0;
            tornadoCenterY = 0;
            tornadoRotation = 0;
            stormActive = false;
          }
          if (fireEffectType) {
            fireEffectType = null;
            fireballCenterX = 0;
            fireballCenterY = 0;
            fireballIntensity = 0;
            explosionActive = false;
            phoenixTrail = [];
          }
          if (spaceEffectType) {
            spaceEffectType = null;
            blackHoleX = 0;
            blackHoleY = 0;
            blackHoleIntensity = 0;
            portalCenterX = 0;
            portalCenterY = 0;
            portalRadius = 0;
            particlesFrozen = false;
            rewindActive = false;
            particles.forEach(p => {
              if (p.history) p.history = [];
            });
          }
          previousRightHandGesture = null;
        }

        // æ£€æµ‹åˆ°æ¯” 1 æ‰‹åŠ¿æ—¶ï¼Œç”Ÿæˆæ–‡å­—ç²’å­ä½ç½®ï¼ˆéçƒä½“æ¨¡å¼ä¸”éåŒæ‰‹åˆæ‹¢æ¨¡å¼ä¸‹æ‰ç”Ÿæ•ˆï¼‰
        // ä½¿ç”¨ç¬¬ä¸€åªæ‰‹çš„æ‰‹åŠ¿ï¼Œä¸”å¿…é¡»æ˜¯å•æ‰‹æ‰èƒ½è§¦å‘
        if (!isSphereMode && !isHandsClosing && !windEffectType && !waterEffectType && !fireEffectType && !spaceEffectType && handsData.length === 1 && handsData[0].gesture === 'one') {
          if (!isFormingText || textTargets.length === 0) {
            isFormingText = true;
            // æ ¹æ®å½“å‰ç”»å¸ƒå¤§å°è‡ªé€‚åº”å­—å·ï¼Œç”Ÿæˆâ€œå­™åŠ æ¬£â€æ–‡å­—ç‚¹é˜µ
            textTargets = generateTextParticles('å­™åŠ æ¬£');

            // åªç”¨ä¸€éƒ¨åˆ†ç²’å­æ‹¼å­—ï¼šé€‰æ‹©é è¿‘å±å¹•ä¸­å¿ƒçš„ç²’å­
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // å¤åˆ¶ä¸€ä»½å¸¦è·ç¦»ä¿¡æ¯çš„ç²’å­æ•°ç»„
            const particlesWithDist = particles.map((p, idx) => {
              const dx = p.x - centerX;
              const dy = p.y - centerY;
              return { p, idx, dist: Math.sqrt(dx * dx + dy * dy) };
            });

            // æŒ‰è·ç¦»ä»è¿‘åˆ°è¿œæ’åº
            particlesWithDist.sort((a, b) => a.dist - b.dist);

            // å‚ä¸æ‹¼å­—çš„ç²’å­æ•°é‡ï¼ˆä¸è¶…è¿‡æ–‡å­—ç‚¹æ•°çš„ 60%ï¼Œä¹Ÿä¸è¶…è¿‡æ€»ç²’å­çš„ 60%ï¼‰
            const maxTextParticles = Math.min(
              Math.floor(particles.length * 0.6),
              Math.floor(textTargets.length * 0.6)
            );

            // å…ˆæ¸…ç©ºæ‰€æœ‰ç²’å­çš„ target
            particles.forEach((particle) => {
              particle.targetX = null;
              particle.targetY = null;
            });

            // è®©è·ç¦»ä¸­å¿ƒæœ€è¿‘çš„ä¸€éƒ¨åˆ†ç²’å­å‚ä¸æ‹¼å­—
            for (let i = 0; i < maxTextParticles; i++) {
              const { p } = particlesWithDist[i];
              const targetIndex = Math.floor(
                (i / Math.max(1, maxTextParticles - 1)) * (textTargets.length - 1)
              );
              p.targetX = textTargets[targetIndex].x;
              p.targetY = textTargets[targetIndex].y;
            }
          }
        }

        const gestureNames = {
          open: 'âœ‹ å¼ å¼€æ‰‹æŒ',
          five: '5ï¸âƒ£ æ¯” 5 æ‰‹åŠ¿',
          closed: 'âœŠ æ¡æ‹³',
          pointing: 'â˜ï¸ é£ŸæŒ‡',
          victory: 'âœŒï¸ èƒœåˆ©æ‰‹åŠ¿',
          one: 'â˜ï¸ æ¯” 1 æ‰‹åŠ¿',
          two: 'âœŒï¸ æ¯” 2',
          three: 'ğŸ¤Ÿ æ¯” 3',
          four: '4ï¸âƒ£ æ¯” 4 æ‰‹åŠ¿',
          six: 'ğŸ¤™ æ¯” 6',
          eight: 'ğŸ¤ æ¯” 8',
          neutral: 'ğŸ–ï¸ è‡ªç„¶',
        };

        statusDiv.className = 'status ready';
        if (isSphereMode && isHandsClosing) {
          statusDiv.textContent = 'æ‰‹åŠ¿: ğŸ‘Šâœ‹ å·¦æ‰‹æ¡æ‹³ + å³æ‰‹æ¯”1 - ç²’å­æ±‡èšæˆçƒä½“';
        } else if (windEffectType) {
          const windEffectNames = {
            'tornado': 'ğŸŒªï¸ æ—‹é£ç”Ÿæˆ',
            'blow': 'ğŸ’¨ ç²’å­å¹æ•£',
            'distortion': 'ğŸŒ€ æ°”æµæŠ˜å°„',
            'storm': 'â›ˆï¸ æš´é£æ¨¡å¼'
          };
          statusDiv.textContent = `æ‰‹åŠ¿: ${windEffectNames[windEffectType] || windEffectType} - é£ç³»ç²’å­æ§åˆ¶`;
        } else if (fireEffectType) {
          const fireEffectNames = {
            'fireball': 'ğŸ”¥ ç«çƒå‡èš',
            'flame': 'ğŸ”¥ ç«ç„°å–·å°„',
            'explosion': 'ğŸ’¥ ç«ç„°çˆ†è£‚',
            'phoenix': 'ğŸ”¥ ç«ç„°å‡¤å‡°'
          };
          statusDiv.textContent = `æ‰‹åŠ¿: ${fireEffectNames[fireEffectType] || fireEffectType} - ç«ç³»ç²’å­æ§åˆ¶`;
        } else if (spaceEffectType) {
          const spaceEffectNames = {
            'blackhole': 'ğŸ•³ï¸ è™«æ´å¸å¼•',
            'portal': 'ğŸŒ€ ç©ºé—´é—¨',
            'freeze': 'â„ï¸ ç²’å­å†»ç»“',
            'rewind': 'âª æ—¶é—´å€’æµ'
          };
          statusDiv.textContent = `æ‰‹åŠ¿: ${spaceEffectNames[spaceEffectType] || spaceEffectType} - ç©ºé—´æ‰­æ›²æ§åˆ¶`;
        } else if (waterEffectType) {
          const waterEffectNames = {
            'ripple': 'ğŸŒŠ æ°´æ³¢æ¶Ÿæ¼ª',
            'rain': 'ğŸŒ§ï¸ é›¨æ»´ç”Ÿæˆ',
            'condense': 'ğŸ’§ ç²’å­å‡ç»“',
            'split': 'ğŸŒŠ æ°´æµåˆ†è£‚'
          };
          statusDiv.textContent = `æ‰‹åŠ¿: ${waterEffectNames[waterEffectType] || waterEffectType} - æ°´ç³»ç²’å­æ§åˆ¶`;
        } else if (advancedEffectType) {
          const advancedEffectNames = {
            'gravityring': 'ğŸŒ  é‡åŠ›æ‰­æ›²ç¯',
            'spiralbeam': 'ğŸŒªï¸ æ—¶ç©ºèºæ—‹æª',
            'gravityarc': 'ğŸ’§ é‡åŠ›æ°´å¼§',
            'storm': 'âš¡ é›·æš´å¼•å¯¼',
            'rainbowcurl': 'ğŸŒˆ é›¶é‡åŠ›å½©è‰²å¼§çº¿',
            'lightning': 'âš¡ åŒæ‰‹é›·ç”µçƒ'
          };
          statusDiv.textContent = `æ‰‹åŠ¿: ${advancedEffectNames[advancedEffectType] || advancedEffectType} - é«˜çº§ç»„åˆæ•ˆæœ`;
        } else if (isSphereMode) {
          statusDiv.textContent = 'æ‰‹åŠ¿: ğŸ”„ æ˜Ÿçƒæ¨¡å¼';
        } else {
          // æ˜¾ç¤ºæ‰€æœ‰æ‰‹çš„æ‰‹åŠ¿
          const currentHandsDataForStatus = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
          if (currentHandsDataForStatus.length === 1) {
        statusDiv.textContent = `æ‰‹åŠ¿: ${
              gestureNames[currentHandsDataForStatus[0].gesture] || currentHandsDataForStatus[0].gesture
            }`;
          } else if (currentHandsDataForStatus.length === 2) {
            statusDiv.textContent = `å·¦æ‰‹: ${gestureNames[currentHandsDataForStatus[0].gesture] || currentHandsDataForStatus[0].gesture} | å³æ‰‹: ${gestureNames[currentHandsDataForStatus[1].gesture] || currentHandsDataForStatus[1].gesture}`;
          } else if (currentHandsDataForStatus.length > 0) {
            statusDiv.textContent = `æ‰‹åŠ¿: ${
              gestureNames[currentHandsDataForStatus[0].gesture] || currentHandsDataForStatus[0].gesture
            }`;
          }
        }

        // æ›´æ–°é€Ÿåº¦æŒ‡ç¤ºå™¨
        const speedIndicator = document.getElementById('speedIndicator');
        const speedValue = document.getElementById('speedValue');
        if (speedIndicator && speedValue) {
          speedIndicator.style.display = 'block';
          speedValue.textContent = (handSpeed * 100).toFixed(0) + '%';
          speedValue.style.color = handSpeed > 0.5 ? '#ff6b6b' : handSpeed > 0.3 ? '#ffd93d' : '#6bcf7f';
        }
      } else {
        handData = null;
        handsData = [];
        previousHandData = null;
        previousHandsData = [];
        handSpeed = 0;
        
        // åªæœ‰åœ¨æ‘„åƒå¤´å·²åˆå§‹åŒ–æ—¶æ‰æ˜¾ç¤º"ç­‰å¾…æ£€æµ‹æ‰‹åŠ¿"
        if (cameraInitialized) {
        statusDiv.className = 'status waiting';
        statusDiv.textContent = 'ç­‰å¾…æ£€æµ‹æ‰‹åŠ¿...';
      }
        
        // æ¸…é™¤æ–‡å­—å½¢æˆçŠ¶æ€
        if (isFormingText) {
          isFormingText = false;
          particles.forEach(p => {
            p.targetX = null;
            p.targetY = null;
          });
        }
        
        const speedIndicator = document.getElementById('speedIndicator');
        if (speedIndicator) {
          speedIndicator.style.display = 'none';
        }
      }
    });

    // å¯åŠ¨æ‘„åƒå¤´ï¼ˆå¸¦é”™è¯¯å¤„ç†å’Œå…¼å®¹æ€§æ£€æµ‹ï¼‰
    let camera = null;
    let initTimeout = null;
    let cameraInitialized = false;

    function initCamera() {
      // æ£€æŸ¥ MediaPipe åº“æ˜¯å¦åŠ è½½
      if (typeof Camera === 'undefined' || typeof Hands === 'undefined') {
        statusDiv.className = 'status waiting';
        statusDiv.textContent = 'âŒ MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
        return;
      }

      // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒæ‘„åƒå¤´
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusDiv.className = 'status waiting';
        statusDiv.textContent = 'âŒ æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ï¼Œè¯·ä½¿ç”¨ Chrome/Edge/Safari';
        return;
      }

      try {
        camera = new Camera(video, {
      onFrame: async () => {
            if (cameraInitialized && hands) {
              try {
        await hands.send({ image: video });
              } catch (err) {
                console.error('æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:', err);
              }
            }
      },
      width: 640,
      height: 480,
    });

        // ç›‘å¬è§†é¢‘æ’­æ”¾ï¼Œç¡®è®¤æ‘„åƒå¤´çœŸæ­£å¯åŠ¨
        video.addEventListener('loadedmetadata', () => {
          if (!cameraInitialized) {
            cameraInitialized = true;
            if (initTimeout) {
              clearTimeout(initTimeout);
              initTimeout = null;
            }
            statusDiv.className = 'status ready';
            statusDiv.textContent = 'âœ… æ‘„åƒå¤´å·²å°±ç»ªï¼Œè¯·å°†æ‰‹ä¼¸åˆ°æ‘„åƒå¤´å‰';
          }
        });

        video.addEventListener('play', () => {
          if (!cameraInitialized) {
            cameraInitialized = true;
            if (initTimeout) {
              clearTimeout(initTimeout);
              initTimeout = null;
            }
            statusDiv.className = 'status ready';
            statusDiv.textContent = 'âœ… æ‘„åƒå¤´å·²å°±ç»ªï¼Œè¯·å°†æ‰‹ä¼¸åˆ°æ‘„åƒå¤´å‰';
          }
        });

        // é”™è¯¯å¤„ç†
        video.addEventListener('error', (e) => {
          if (initTimeout) {
            clearTimeout(initTimeout);
            initTimeout = null;
          }
          statusDiv.className = 'status waiting';
          statusDiv.textContent = 'âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–åˆ·æ–°é¡µé¢';
          console.error('æ‘„åƒå¤´é”™è¯¯:', e);
        });

        // å¯åŠ¨æ‘„åƒå¤´
        camera.start().catch((err) => {
          if (initTimeout) {
            clearTimeout(initTimeout);
            initTimeout = null;
          }
          statusDiv.className = 'status waiting';
          
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            statusDiv.textContent = 'âŒ æ‘„åƒå¤´æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®æ‘„åƒå¤´';
          } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            statusDiv.textContent = 'âŒ æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡';
          } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
            statusDiv.textContent = 'âŒ æ‘„åƒå¤´è¢«å…¶ä»–åº”ç”¨å ç”¨ï¼Œè¯·å…³é—­å…¶ä»–åº”ç”¨ååˆ·æ–°';
          } else {
            statusDiv.textContent = 'âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: ' + err.message;
          }
          console.error('æ‘„åƒå¤´å¯åŠ¨é”™è¯¯:', err);
        });

        // è¶…æ—¶æ£€æµ‹ï¼ˆ15ç§’åå¦‚æœè¿˜æ²¡å¯åŠ¨ï¼Œæç¤ºç”¨æˆ·ï¼‰
        initTimeout = setTimeout(() => {
          if (!cameraInitialized) {
            statusDiv.className = 'status waiting';
            statusDiv.textContent = 'â±ï¸ æ‘„åƒå¤´åˆå§‹åŒ–è¶…æ—¶ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–åˆ·æ–°é¡µé¢';
          }
        }, 15000);

      } catch (err) {
        if (initTimeout) {
          clearTimeout(initTimeout);
          initTimeout = null;
        }
        statusDiv.className = 'status waiting';
        statusDiv.textContent = 'âŒ åˆå§‹åŒ–å¤±è´¥: ' + err.message;
        console.error('åˆå§‹åŒ–é”™è¯¯:', err);
      }
    }

    // ç­‰å¾… MediaPipe åº“åŠ è½½å®Œæˆåå†åˆå§‹åŒ–æ‘„åƒå¤´
    if (typeof Camera !== 'undefined' && typeof Hands !== 'undefined') {
      // åº“å·²åŠ è½½ï¼Œç›´æ¥åˆå§‹åŒ–
      initCamera();
    } else {
      // ç­‰å¾…åº“åŠ è½½
      window.addEventListener('load', () => {
        // å†ç­‰ä¸€å°æ®µæ—¶é—´ç¡®ä¿åº“å®Œå…¨åŠ è½½
        setTimeout(() => {
          initCamera();
        }, 500);
      });
    }

    // åŠ¨ç”»å¾ªç¯
    function animate() {
      // æ›´æ–°å½©è™¹æ¨¡å¼
      if (rainbowMode) {
        rainbowHue = (rainbowHue + 1) % 360;
      }

      // æ›´æ–°è·³èˆåŠ¨ç”»ï¼ˆå¦‚æœæ­£åœ¨è·³èˆï¼Œä¸”ä¸åœ¨åŒæ‰‹åˆæ‹¢æ¨¡å¼ï¼‰
      if (isDancing && !isHandsClosing) {
        danceFrame++;
        meteorFrame++; // æ›´æ–°æµæ˜ŸåŠ¨ç”»å¸§æ•°
        // é‡æ–°ç”Ÿæˆè·³èˆå°äººä½ç½®ï¼ˆå®ç°åŠ¨ç”»æ•ˆæœï¼‰
        danceTargets = generateDancingFigures(danceFrame);
        
        // ä½¿ç”¨ä¿å­˜çš„targetIndexæ›´æ–°ç²’å­çš„ç›®æ ‡ä½ç½®ï¼ˆæ›´é«˜æ•ˆï¼‰
        particles.forEach(p => {
          if (p.targetIndex !== null && p.targetIndex < danceTargets.length) {
            p.targetX = danceTargets[p.targetIndex].x;
            p.targetY = danceTargets[p.targetIndex].y;
          }
        });
      }

      // èƒŒæ™¯æ‹–å½±
      ctx.fillStyle = 'rgba(10, 10, 30, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // æ›´æ–°å’Œç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
      explosions = explosions.filter((explosion) => {
        explosion.update();
        explosion.draw();
        return explosion.particles.length > 0;
      });

      // çƒä½“æ¨¡å¼ä¸‹ï¼Œæ•´ä½“æ—‹è½¬
      if (isSphereMode) {
        sphereRotation += 0.01;
      }

      // ç»˜åˆ¶ç«ç³»æ•ˆæœå¯è§†åŒ–
      if (fireEffectType && !isHandsClosing) {
        const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        
        if (fireEffectType === 'fireball' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶ç«çƒå‡èšæ•ˆæœ
          if (fireballCenterX > 0 && fireballCenterY > 0 && fireballIntensity > 0) {
            const radius = 120 + fireballIntensity * 100; // ç«çƒåŠå¾„ï¼ˆæ‰©å¤§å¯è§†åŒ–ï¼‰
            
            // ç»˜åˆ¶ç«çƒå¤–å±‚å…‰æ™•
            const gradient = ctx.createRadialGradient(
              fireballCenterX, fireballCenterY, 0,
              fireballCenterX, fireballCenterY, radius
            );
            gradient.addColorStop(0, `rgba(255, 100, 0, ${fireballIntensity * 0.8})`);
            gradient.addColorStop(0.5, `rgba(255, 150, 0, ${fireballIntensity * 0.4})`);
            gradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(fireballCenterX, fireballCenterY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ç«çƒæ ¸å¿ƒ
            const coreRadius = 30 + fireballIntensity * 50;
            const coreGradient = ctx.createRadialGradient(
              fireballCenterX, fireballCenterY, 0,
              fireballCenterX, fireballCenterY, coreRadius
            );
            coreGradient.addColorStop(0, `rgba(255, 255, 200, ${fireballIntensity})`);
            coreGradient.addColorStop(1, `rgba(255, 150, 0, ${fireballIntensity * 0.6})`);
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(fireballCenterX, fireballCenterY, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬çš„èƒ½é‡ç¯
            const ringAngle = Date.now() * 0.005;
            for (let i = 0; i < 3; i++) {
              const ringRadius = radius * 0.7 + i * 10;
              const ringX = fireballCenterX + Math.cos(ringAngle + i * Math.PI * 2 / 3) * ringRadius;
              const ringY = fireballCenterY + Math.sin(ringAngle + i * Math.PI * 2 / 3) * ringRadius;
              
              ctx.fillStyle = `rgba(255, 200, 100, ${fireballIntensity * 0.6})`;
              ctx.beginPath();
              ctx.arc(ringX, ringY, 5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (fireEffectType === 'flame' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶ç«ç„°å–·å°„æ•ˆæœ
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand && rightHand.landmarks) {
            const indexTip = rightHand.landmarks[8];
            const indexTipX = indexTip.x * canvas.width;
            const indexTipY = indexTip.y * canvas.height;
            
            const middleTip = rightHand.landmarks[12];
            const middleTipX = middleTip.x * canvas.width;
            const middleTipY = middleTip.y * canvas.height;
            
            const flameDx = middleTipX - indexTipX;
            const flameDy = middleTipY - indexTipY;
            const flameDist = Math.sqrt(flameDx * flameDx + flameDy * flameDy);
            
            if (flameDist > 0) {
              const flameAngle = Math.atan2(flameDy, flameDx);
              const sprayWidth = Math.min(100, flameDist * 3);
              const sprayLength = 350;
              
              // ç»˜åˆ¶ç«ç„°å–·å°„è½¨è¿¹
              for (let i = 0; i < 8; i++) {
                const t = i / 8;
                const x = indexTipX + Math.cos(flameAngle) * sprayLength * t;
                const y = indexTipY + Math.sin(flameAngle) * sprayLength * t;
                const size = (1 - t) * sprayWidth * 0.3;
                
                const flameGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                flameGradient.addColorStop(0, `rgba(255, 200, 0, ${(1 - t) * 0.8})`);
                flameGradient.addColorStop(0.5, `rgba(255, 100, 0, ${(1 - t) * 0.5})`);
                flameGradient.addColorStop(1, `rgba(255, 50, 0, 0)`);
                
                ctx.fillStyle = flameGradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
        } else if (fireEffectType === 'explosion' && explosionActive) {
          // ç»˜åˆ¶ç«ç„°çˆ†è£‚æ•ˆæœï¼ˆåŒæ‰‹å‡ºç°ç«ç„°ç”Ÿæˆï¼Œç«ç„°çš„å½¢çŠ¶ä¸€å®šè¦éå¸¸çš„æ˜æ˜¾ï¼ŒåŒæ‰‹éƒ½è¦æœ‰ï¼‰
          const leftHand = currentHandsDataForDraw.find(h => h.handedness === 'Left') || currentHandsDataForDraw[0];
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          
          const elapsed = Date.now() - explosionStartTime;
          const duration = 2000;
          const progress = Math.min(1, elapsed / duration);
          
          // ç»˜åˆ¶å³æ‰‹ç«ç„°ç”Ÿæˆ
          if (rightHand) {
            const explosionX = rightHand.palmX * canvas.width;
            const explosionY = rightHand.palmY * canvas.height;
            
            // ç»˜åˆ¶ç«ç„°å½¢çŠ¶ï¼ˆé”¥å½¢ï¼Œåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„ï¼‰
            const flameHeight = 400;
            const baseRadius = 120;
            const topRadius = 20;
            
            // ç»˜åˆ¶å¤šå±‚ç«ç„°ï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
            for (let layer = 0; layer < 6; layer++) {
              const heightRatio = layer / 6;
              const y = explosionY - flameHeight * heightRatio;
              const radius = baseRadius * (1 - heightRatio) + topRadius * heightRatio;
              const layerAlpha = (1 - progress) * (1 - heightRatio * 0.3);
              
              // å¤–å±‚ç«ç„°ï¼ˆçº¢è‰²åˆ°æ©™è‰²ï¼‰
              const outerGradient = ctx.createRadialGradient(
                explosionX, y, 0,
                explosionX, y, radius * 1.2
              );
              outerGradient.addColorStop(0, `rgba(255, 100, 0, ${layerAlpha * 0.6})`);
              outerGradient.addColorStop(0.5, `rgba(255, 150, 0, ${layerAlpha * 0.4})`);
              outerGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
              
              ctx.fillStyle = outerGradient;
              ctx.shadowBlur = 15;
              ctx.shadowColor = `rgba(255, 150, 0, ${layerAlpha * 0.5})`;
              ctx.beginPath();
              ctx.ellipse(explosionX, y, radius * 1.2, radius * 0.8, Date.now() * 0.005, 0, Math.PI * 2);
              ctx.fill();
              
              // å†…å±‚ç«ç„°ï¼ˆæ©™è‰²åˆ°é»„è‰²ï¼‰
              const innerGradient = ctx.createRadialGradient(
                explosionX, y, 0,
                explosionX, y, radius * 0.6
              );
              innerGradient.addColorStop(0, `rgba(255, 200, 0, ${layerAlpha * 0.8})`);
              innerGradient.addColorStop(0.5, `rgba(255, 255, 150, ${layerAlpha * 0.6})`);
              innerGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
              
              ctx.fillStyle = innerGradient;
              ctx.beginPath();
              ctx.ellipse(explosionX, y, radius * 0.6, radius * 0.4, Date.now() * 0.005, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // ç»˜åˆ¶ç«ç„°æ ¸å¿ƒï¼ˆé«˜äº®ç™½è‰²ï¼‰
            const coreGradient = ctx.createRadialGradient(
              explosionX, explosionY, 0,
              explosionX, explosionY, 50
            );
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${(1 - progress) * 1.0})`);
            coreGradient.addColorStop(0.3, `rgba(255, 255, 200, ${(1 - progress) * 0.8})`);
            coreGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
            
            ctx.fillStyle = coreGradient;
            ctx.shadowBlur = 25;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(explosionX, explosionY, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ç«ç„°è·³åŠ¨æ•ˆæœï¼ˆéšæœºäº®ç‚¹ï¼‰
            for (let i = 0; i < 15; i++) {
              const sparkAngle = (i / 15) * Math.PI * 2 + Date.now() * 0.01;
              const sparkDist = 60 + Math.random() * 80;
              const sparkHeight = Math.random() * flameHeight;
              const sparkX = explosionX + Math.cos(sparkAngle) * sparkDist * 0.3;
              const sparkY = explosionY - sparkHeight;
              const sparkSize = 3 + Math.random() * 4;
              
              const sparkGradient = ctx.createRadialGradient(
                sparkX, sparkY, 0,
                sparkX, sparkY, sparkSize
              );
              sparkGradient.addColorStop(0, `rgba(255, 255, 200, ${(1 - progress) * 0.8})`);
              sparkGradient.addColorStop(1, `rgba(255, 150, 0, 0)`);
              
              ctx.fillStyle = sparkGradient;
              ctx.shadowBlur = 8;
              ctx.shadowColor = `rgba(255, 200, 0, ${(1 - progress) * 0.5})`;
              ctx.beginPath();
              ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // ç»˜åˆ¶å·¦æ‰‹ç«ç„°ç”Ÿæˆ
          if (leftHand) {
            const explosionX = leftHand.palmX * canvas.width;
            const explosionY = leftHand.palmY * canvas.height;
            
            // ç»˜åˆ¶ç«ç„°å½¢çŠ¶ï¼ˆé”¥å½¢ï¼Œåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„ï¼‰
            const flameHeight = 400;
            const baseRadius = 120;
            const topRadius = 20;
            
            // ç»˜åˆ¶å¤šå±‚ç«ç„°ï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
            for (let layer = 0; layer < 6; layer++) {
              const heightRatio = layer / 6;
              const y = explosionY - flameHeight * heightRatio;
              const radius = baseRadius * (1 - heightRatio) + topRadius * heightRatio;
              const layerAlpha = (1 - progress) * (1 - heightRatio * 0.3);
              
              // å¤–å±‚ç«ç„°ï¼ˆçº¢è‰²åˆ°æ©™è‰²ï¼‰
              const outerGradient = ctx.createRadialGradient(
                explosionX, y, 0,
                explosionX, y, radius * 1.2
              );
              outerGradient.addColorStop(0, `rgba(255, 100, 0, ${layerAlpha * 0.6})`);
              outerGradient.addColorStop(0.5, `rgba(255, 150, 0, ${layerAlpha * 0.4})`);
              outerGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
              
              ctx.fillStyle = outerGradient;
              ctx.shadowBlur = 15;
              ctx.shadowColor = `rgba(255, 150, 0, ${layerAlpha * 0.5})`;
              ctx.beginPath();
              ctx.ellipse(explosionX, y, radius * 1.2, radius * 0.8, Date.now() * 0.005, 0, Math.PI * 2);
              ctx.fill();
              
              // å†…å±‚ç«ç„°ï¼ˆæ©™è‰²åˆ°é»„è‰²ï¼‰
              const innerGradient = ctx.createRadialGradient(
                explosionX, y, 0,
                explosionX, y, radius * 0.6
              );
              innerGradient.addColorStop(0, `rgba(255, 200, 0, ${layerAlpha * 0.8})`);
              innerGradient.addColorStop(0.5, `rgba(255, 255, 150, ${layerAlpha * 0.6})`);
              innerGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
              
              ctx.fillStyle = innerGradient;
              ctx.beginPath();
              ctx.ellipse(explosionX, y, radius * 0.6, radius * 0.4, Date.now() * 0.005, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // ç»˜åˆ¶ç«ç„°æ ¸å¿ƒï¼ˆé«˜äº®ç™½è‰²ï¼‰
            const coreGradient = ctx.createRadialGradient(
              explosionX, explosionY, 0,
              explosionX, explosionY, 50
            );
            coreGradient.addColorStop(0, `rgba(255, 255, 255, ${(1 - progress) * 1.0})`);
            coreGradient.addColorStop(0.3, `rgba(255, 255, 200, ${(1 - progress) * 0.8})`);
            coreGradient.addColorStop(1, `rgba(255, 200, 0, 0)`);
            
            ctx.fillStyle = coreGradient;
            ctx.shadowBlur = 25;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(explosionX, explosionY, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ç«ç„°è·³åŠ¨æ•ˆæœï¼ˆéšæœºäº®ç‚¹ï¼‰
            for (let i = 0; i < 15; i++) {
              const sparkAngle = (i / 15) * Math.PI * 2 + Date.now() * 0.01;
              const sparkDist = 60 + Math.random() * 80;
              const sparkHeight = Math.random() * flameHeight;
              const sparkX = explosionX + Math.cos(sparkAngle) * sparkDist * 0.3;
              const sparkY = explosionY - sparkHeight;
              const sparkSize = 3 + Math.random() * 4;
              
              const sparkGradient = ctx.createRadialGradient(
                sparkX, sparkY, 0,
                sparkX, sparkY, sparkSize
              );
              sparkGradient.addColorStop(0, `rgba(255, 255, 200, ${(1 - progress) * 0.8})`);
              sparkGradient.addColorStop(1, `rgba(255, 150, 0, 0)`);
              
              ctx.fillStyle = sparkGradient;
              ctx.shadowBlur = 8;
              ctx.shadowColor = `rgba(255, 200, 0, ${(1 - progress) * 0.5})`;
              ctx.beginPath();
              ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          ctx.shadowBlur = 0; // é‡ç½®é˜´å½±
        } else if (fireEffectType === 'phoenix' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶ç«ç„°å‡¤å‡°æ•ˆæœ
          if (phoenixPosition.x > 0 && phoenixPosition.y > 0) {
            // ç»˜åˆ¶å‡¤å‡°å°¾è¿¹
            if (phoenixTrail.length > 1) {
              ctx.strokeStyle = 'rgba(255, 150, 0, 0.6)';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(phoenixTrail[0].x, phoenixTrail[0].y);
              for (let i = 1; i < phoenixTrail.length; i++) {
                ctx.lineTo(phoenixTrail[i].x, phoenixTrail[i].y);
              }
              ctx.stroke();
              
              // ç»˜åˆ¶å°¾è¿¹ç²’å­
              phoenixTrail.forEach((point, i) => {
                const alpha = (i / phoenixTrail.length) * 0.8;
                const size = 5 + (i / phoenixTrail.length) * 10;
                const phoenixGradient = ctx.createRadialGradient(
                  point.x, point.y, 0,
                  point.x, point.y, size
                );
                phoenixGradient.addColorStop(0, `rgba(255, 200, 0, ${alpha})`);
                phoenixGradient.addColorStop(1, `rgba(255, 100, 0, 0)`);
                
                ctx.fillStyle = phoenixGradient;
                ctx.beginPath();
                ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                ctx.fill();
              });
            }
            
            // ç»˜åˆ¶å‡¤å‡°æ ¸å¿ƒ
            const phoenixCoreGradient = ctx.createRadialGradient(
              phoenixPosition.x, phoenixPosition.y, 0,
              phoenixPosition.x, phoenixPosition.y, 40
            );
            phoenixCoreGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
            phoenixCoreGradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.7)');
            phoenixCoreGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            
            ctx.fillStyle = phoenixCoreGradient;
            ctx.beginPath();
            ctx.arc(phoenixPosition.x, phoenixPosition.y, 40, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // ç»˜åˆ¶é£ç³»æ•ˆæœå¯è§†åŒ–
      if (windEffectType && !isHandsClosing) {
        const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        
        if (windEffectType === 'tornado' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶é¾™å·é£æ•ˆæœï¼ˆå¤§å¹…å¢å¼ºè§†è§‰æ•ˆæœï¼‰
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand && tornadoCenterX > 0 && tornadoCenterY > 0) {
            const bottomY = canvas.height;
            const topY = tornadoCenterY - 300;
            const tornadoHeight = bottomY - topY;
            
            // ç»˜åˆ¶é¾™å·é£ä¸»ä½“ï¼ˆé”¥å½¢ï¼Œå¤šå±‚æ¸å˜ï¼‰
            for (let layer = 0; layer < 8; layer++) {
              const heightRatio = layer / 8;
              const y = topY + tornadoHeight * heightRatio;
              const baseRadius = 250 * 0.9;
              const topRadius = 250 * 0.1;
              const radius = baseRadius * (1 - heightRatio) + topRadius * heightRatio;
              
              // å¤–å±‚å…‰æ™•
              const outerGradient = ctx.createRadialGradient(
                tornadoCenterX, y, 0,
                tornadoCenterX, y, radius * 1.2
              );
              outerGradient.addColorStop(0, `rgba(150, 150, 150, ${0.4 * (1 - heightRatio * 0.6)})`);
              outerGradient.addColorStop(0.5, `rgba(200, 200, 200, ${0.2 * (1 - heightRatio * 0.6)})`);
              outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
              
              ctx.fillStyle = outerGradient;
              ctx.beginPath();
              ctx.ellipse(tornadoCenterX, y, radius * 1.2, radius * 0.8, tornadoRotation * 0.5, 0, Math.PI * 2);
              ctx.fill();
              
              // å†…å±‚æ ¸å¿ƒï¼ˆæ›´äº®ï¼‰
              const innerGradient = ctx.createRadialGradient(
                tornadoCenterX, y, 0,
                tornadoCenterX, y, radius * 0.6
              );
              innerGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * (1 - heightRatio * 0.5)})`);
              innerGradient.addColorStop(0.5, `rgba(220, 220, 220, ${0.4 * (1 - heightRatio * 0.5)})`);
              innerGradient.addColorStop(1, 'rgba(180, 180, 180, 0)');
              
              ctx.fillStyle = innerGradient;
              ctx.beginPath();
              ctx.ellipse(tornadoCenterX, y, radius * 0.6, radius * 0.4, tornadoRotation * 0.5, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // ç»˜åˆ¶æ—‹è½¬çš„èºæ—‹çº¿ï¼ˆå¢å¼ºé¾™å·é£å½¢çŠ¶ï¼‰
            for (let i = 0; i < 6; i++) {
              const spiralAngle = tornadoRotation * 2 + (i / 6) * Math.PI * 2;
              ctx.strokeStyle = `rgba(200, 200, 200, 0.5)`;
              ctx.lineWidth = 2;
              ctx.shadowBlur = 10;
              ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
              ctx.beginPath();
              
              for (let h = 0; h <= 20; h++) {
                const heightRatio = h / 20;
                const y = topY + tornadoHeight * heightRatio;
                const baseRadius = 250 * 0.9;
                const topRadius = 250 * 0.1;
                const radius = baseRadius * (1 - heightRatio) + topRadius * heightRatio;
                const angle = spiralAngle + heightRatio * Math.PI * 4;
                const x = tornadoCenterX + Math.cos(angle) * radius;
                const yPos = y + Math.sin(angle) * radius * 0.3;
                
                if (h === 0) {
                  ctx.moveTo(x, yPos);
                } else {
                  ctx.lineTo(x, yPos);
                }
              }
              ctx.stroke();
            }
            
            // ç»˜åˆ¶åº•éƒ¨ä¸­å¿ƒç‚¹ï¼ˆé¾™å·é£èµ·ç‚¹ï¼‰
            const bottomGradient = ctx.createRadialGradient(
              tornadoCenterX, bottomY, 0,
              tornadoCenterX, bottomY, 80
            );
            bottomGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            bottomGradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.5)');
            bottomGradient.addColorStop(1, 'rgba(150, 150, 150, 0)');
            
            ctx.fillStyle = bottomGradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(tornadoCenterX, bottomY, 80, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶é¡¶éƒ¨ï¼ˆäº‘å±‚æ•ˆæœï¼‰
            const topGradient = ctx.createRadialGradient(
              tornadoCenterX, topY, 0,
              tornadoCenterX, topY, 60
            );
            topGradient.addColorStop(0, 'rgba(180, 180, 180, 0.6)');
            topGradient.addColorStop(1, 'rgba(150, 150, 150, 0)');
            
            ctx.fillStyle = topGradient;
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(200, 200, 200, 0.4)';
            ctx.beginPath();
            ctx.arc(tornadoCenterX, topY, 60, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0; // é‡ç½®é˜´å½±
          }
        }
      }

      // ç»˜åˆ¶æ°´ç³»æ•ˆæœå¯è§†åŒ–
      if (waterEffectType && !isHandsClosing) {
        const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        
        if (waterEffectType === 'ripple' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶æ°´æ³¢æ¶Ÿæ¼ªï¼ˆå¤§å¹…å¢å¼ºè§†è§‰æ•ˆæœï¼‰
          rippleWaves.forEach(wave => {
            if (wave.radius > 0 && wave.radius < 800 && wave.amplitude > 0.05) {
              // ç»˜åˆ¶æœ€å¤–å±‚å…‰æ™•ï¼ˆå¢å¼ºèŒƒå›´ï¼‰
              const outerGradient = ctx.createRadialGradient(
                wave.x, wave.y, wave.radius - 40,
                wave.x, wave.y, wave.radius + 40
              );
              outerGradient.addColorStop(0, `rgba(100, 150, 255, ${(wave.amplitude / 50) * 0.3})`);
              outerGradient.addColorStop(1, `rgba(150, 200, 255, 0)`);
              
              ctx.fillStyle = outerGradient;
              ctx.beginPath();
              ctx.arc(wave.x, wave.y, wave.radius + 40, 0, Math.PI * 2);
              ctx.fill();
              
              // ç»˜åˆ¶å¤šå±‚æ¶Ÿæ¼ªåœ†ç¯ï¼ˆå¢å¼ºå±‚æ¬¡æ„Ÿå’Œäº®åº¦ï¼‰
              for (let i = 0; i < 5; i++) { // å¢åŠ å±‚æ•°ä»3åˆ°5
                const offset = i * 20;
                const alpha = (wave.amplitude / 50) * (1 - wave.radius / 800) * (1 - i * 0.2);
                ctx.strokeStyle = `rgba(150, 200, 255, ${alpha * 1.2})`; // å¢å¼ºäº®åº¦
                ctx.lineWidth = 4 - i * 0.5; // å¢åŠ çº¿å®½
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.radius - offset, 0, Math.PI * 2);
                ctx.stroke();
              }
              
              // ç»˜åˆ¶æ¶Ÿæ¼ªä¸­å¿ƒç‚¹ï¼ˆå¢å¼ºèµ·å§‹ç‚¹ï¼Œæ›´å¤§æ›´äº®ï¼‰
              if (wave.radius < 80) { // æ‰©å¤§ä¸­å¿ƒæ˜¾ç¤ºèŒƒå›´
                const centerAlpha = (wave.amplitude / 50) * (1 - wave.radius / 80);
                const centerGradient = ctx.createRadialGradient(
                  wave.x, wave.y, 0,
                  wave.x, wave.y, 40 // å¢å¤§ä¸­å¿ƒåŠå¾„
                );
                centerGradient.addColorStop(0, `rgba(200, 220, 255, ${centerAlpha * 1.0})`); // å¢å¼ºäº®åº¦
                centerGradient.addColorStop(0.5, `rgba(150, 200, 255, ${centerAlpha * 0.7})`);
                centerGradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
                
                ctx.fillStyle = centerGradient;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, 40, 0, Math.PI * 2);
                ctx.fill();
              }
              
              // ç»˜åˆ¶æ¶Ÿæ¼ªæ³¢çº¹ç»†èŠ‚ï¼ˆå¢å¼ºåŠ¨æ€æ„Ÿå’Œæ•°é‡ï¼‰
              const wavePhase = wave.time * 3; // åŠ å¿«æ—‹è½¬
              for (let j = 0; j < 16; j++) { // å¢åŠ ç²’å­æ•°é‡ä»8åˆ°16
                const angle = (j / 16) * Math.PI * 2 + wavePhase;
                const rippleX = wave.x + Math.cos(angle) * wave.radius;
                const rippleY = wave.y + Math.sin(angle) * wave.radius;
                
                // ç»˜åˆ¶ç²’å­å…‰æ™•
                const particleGradient = ctx.createRadialGradient(
                  rippleX, rippleY, 0,
                  rippleX, rippleY, 6
                );
                particleGradient.addColorStop(0, `rgba(200, 220, 255, ${(wave.amplitude / 50) * 0.9})`);
                particleGradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
                
                ctx.fillStyle = particleGradient;
                ctx.beginPath();
                ctx.arc(rippleX, rippleY, 6, 0, Math.PI * 2); // å¢å¤§ç²’å­å°ºå¯¸
                ctx.fill();
              }
            }
          });
        } else if (waterEffectType === 'rain' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶é›¨æ»´ï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
          rainParticles.forEach(drop => {
            if (drop.life > 0) {
              // ç»˜åˆ¶é›¨æ»´ä¸»ä½“ï¼ˆå¢å¼ºäº®åº¦å’Œå¤§å°ï¼‰
              const dropGradient = ctx.createRadialGradient(
                drop.x, drop.y, 0,
                drop.x, drop.y, drop.size
              );
              dropGradient.addColorStop(0, `rgba(200, 220, 255, ${drop.life * 0.9})`);
              dropGradient.addColorStop(0.5, `rgba(150, 180, 255, ${drop.life * 0.7})`);
              dropGradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
              
              ctx.fillStyle = dropGradient;
              ctx.beginPath();
              ctx.arc(drop.x, drop.y, drop.size, 0, Math.PI * 2);
              ctx.fill();
              
              // ç»˜åˆ¶é›¨æ»´é«˜å…‰
              ctx.fillStyle = `rgba(255, 255, 255, ${drop.life * 0.6})`;
              ctx.beginPath();
              ctx.arc(drop.x - drop.size * 0.3, drop.y - drop.size * 0.3, drop.size * 0.3, 0, Math.PI * 2);
              ctx.fill();
              
              // ç»˜åˆ¶é›¨æ»´è½¨è¿¹ï¼ˆå¢å¼ºé•¿åº¦å’Œäº®åº¦ï¼‰
              ctx.strokeStyle = `rgba(150, 200, 255, ${drop.life * 0.5})`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(drop.x, drop.y);
              ctx.lineTo(drop.x - drop.vx * 5, drop.y - drop.vy * 5);
              ctx.stroke();
            }
          });
          
          // ç»˜åˆ¶æº…å°„ç²’å­ï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
          // æº…å°„ç²’å­ä¹Ÿå­˜å‚¨åœ¨ rainParticles ä¸­ï¼Œé€šè¿‡ life å€¼åŒºåˆ†
          rainParticles.forEach(splash => {
            // æº…å°„ç²’å­é€šå¸¸ life è¾ƒå°ä¸” vy ä¸ºè´Ÿï¼ˆå‘ä¸Šé£ï¼‰
            if (splash.life > 0 && splash.life < 0.7 && splash.vy < 0) {
              // ç»˜åˆ¶æº…å°„ç²’å­å…‰æ™•
              const splashGradient = ctx.createRadialGradient(
                splash.x, splash.y, 0,
                splash.x, splash.y, splash.size * 2
              );
              splashGradient.addColorStop(0, `rgba(200, 220, 255, ${splash.life * 0.8})`);
              splashGradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
              
              ctx.fillStyle = splashGradient;
              ctx.beginPath();
              ctx.arc(splash.x, splash.y, splash.size * 2, 0, Math.PI * 2);
              ctx.fill();
              
              // ç»˜åˆ¶æº…å°„ç²’å­æ ¸å¿ƒ
              ctx.fillStyle = `rgba(150, 200, 255, ${splash.life})`;
              ctx.beginPath();
              ctx.arc(splash.x, splash.y, splash.size, 0, Math.PI * 2);
              ctx.fill();
            }
          });
        } else if (waterEffectType === 'condense' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶ç²’å­å‡ç»“æ•ˆæœï¼ˆå¢å¼ºæ°´æ»´èšé›†è§†è§‰æ•ˆæœï¼‰
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand) {
            const handX = rightHand.palmX * canvas.width;
            const handY = rightHand.palmY * canvas.height;
            
            // ç»˜åˆ¶å¤–å±‚å…‰æ™•ï¼ˆæ›´å¤§èŒƒå›´ï¼‰
            const outerGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 300
            );
            outerGradient.addColorStop(0, 'rgba(100, 150, 255, 0.3)');
            outerGradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 300, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ä¸­å±‚å…‰æ™•
            const midGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 250
            );
            midGradient.addColorStop(0, 'rgba(100, 150, 255, 0.6)');
            midGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
            midGradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
            
            ctx.fillStyle = midGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 250, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å†…å±‚æ ¸å¿ƒï¼ˆæ°´æ»´èšé›†ä¸­å¿ƒï¼‰
            const coreGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 80
            );
            coreGradient.addColorStop(0, 'rgba(200, 220, 255, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.7)');
            coreGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 80, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬çš„æ°´æ»´ç²’å­ï¼ˆå¢å¼ºåŠ¨æ€æ„Ÿï¼‰
            const particleAngle = Date.now() * 0.01;
            for (let i = 0; i < 8; i++) {
              const angle = particleAngle + (i / 8) * Math.PI * 2;
              const radius = 100 + Math.sin(particleAngle + i) * 20;
              const px = handX + Math.cos(angle) * radius;
              const py = handY + Math.sin(angle) * radius;
              
              ctx.fillStyle = `rgba(150, 200, 255, 0.8)`;
              ctx.beginPath();
              ctx.arc(px, py, 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (waterEffectType === 'split' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶æ°´æµåˆ†è£‚æ•ˆæœï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand) {
            const handX = rightHand.palmX * canvas.width;
            const handY = rightHand.palmY * canvas.height;
            
            // ç»˜åˆ¶åˆ†è£‚ä¸­å¿ƒå…‰æ™•
            const centerGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 200
            );
            centerGradient.addColorStop(0, 'rgba(100, 150, 255, 0.4)');
            centerGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.2)');
            centerGradient.addColorStop(1, 'rgba(200, 220, 255, 0)');
            
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 200, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶åˆ†è£‚ä¸­å¿ƒæ ¸å¿ƒ
            const coreGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 30
            );
            coreGradient.addColorStop(0, 'rgba(200, 220, 255, 0.9)');
            coreGradient.addColorStop(1, 'rgba(100, 150, 255, 0.5)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 30, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶åˆ†è£‚æµçº¿ï¼ˆå¢å¼ºç®­å¤´å’Œäº®åº¦ï¼‰
            const splitAngle = Date.now() * 0.005;
            for (let i = 0; i < 12; i++) {
              const baseAngle = (i / 12) * Math.PI * 2 + splitAngle;
              const direction = Math.sin(baseAngle) > 0 ? -Math.PI / 4 : Math.PI / 4;
              const streamAngle = baseAngle + direction;
              const endX = handX + Math.cos(streamAngle) * 200;
              const endY = handY + Math.sin(streamAngle) * 200;
              
              // ç»˜åˆ¶æµçº¿ä¸»ä½“
              ctx.strokeStyle = `rgba(150, 200, 255, 0.8)`;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(handX, handY);
              ctx.lineTo(endX, endY);
              ctx.stroke();
              
              // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
              ctx.fillStyle = `rgba(200, 220, 255, 0.9)`;
              ctx.beginPath();
              ctx.moveTo(endX, endY);
              ctx.lineTo(endX - Math.cos(streamAngle - 0.3) * 20, endY - Math.sin(streamAngle - 0.3) * 20);
              ctx.lineTo(endX - Math.cos(streamAngle + 0.3) * 20, endY - Math.sin(streamAngle + 0.3) * 20);
              ctx.closePath();
              ctx.fill();
            }
          }
        }
      }

      // ç»˜åˆ¶é«˜çº§ç»„åˆæ•ˆæœå¯è§†åŒ–
      if (advancedEffectType && !isHandsClosing) {
        const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        
        if (advancedEffectType === 'gravityring' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶é‡åŠ›æ‰­æ›²ç¯
          if (gravityRingRadius > 0) {
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(gravityRingCenterX, gravityRingCenterY, gravityRingRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶æ—‹è½¬æ ‡è®°
            const markerAngle = gravityRingAngle;
            for (let i = 0; i < 8; i++) {
              const angle = markerAngle + (i / 8) * Math.PI * 2;
              const mx = gravityRingCenterX + Math.cos(angle) * gravityRingRadius;
              const my = gravityRingCenterY + Math.sin(angle) * gravityRingRadius;
              ctx.fillStyle = 'rgba(150, 220, 255, 0.9)';
              ctx.beginPath();
              ctx.arc(mx, my, 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (advancedEffectType === 'spiralbeam' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶æ—¶ç©ºèºæ—‹æª
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand) {
            const handX = rightHand.palmX * canvas.width;
            const handY = rightHand.palmY * canvas.height;
            
            // ç»˜åˆ¶èºæ—‹è·¯å¾„
            for (let i = 0; i < 20; i++) {
              const t = i / 20;
              const angle = spiralBeamRotation * 5 + t * Math.PI * 4;
              const radius = t * 200;
              const x = handX + Math.cos(angle) * radius;
              const y = handY + Math.sin(angle) * radius;
              
              ctx.fillStyle = `rgba(200, 100, 255, ${1 - t})`;
              ctx.beginPath();
              ctx.arc(x, y, 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        } else if (advancedEffectType === 'gravityarc' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶é‡åŠ›æ°´å¼§ï¼ˆæ°´æµæ•ˆæœï¼‰
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          const leftHand = currentHandsDataForDraw.find(h => h.handedness === 'Left') || currentHandsDataForDraw[0];
          if (rightHand && leftHand) {
            const rightX = rightHand.palmX * canvas.width;
            const rightY = rightHand.palmY * canvas.height;
            const leftX = leftHand.palmX * canvas.width;
            const leftY = leftHand.palmY * canvas.height;
            
            // ç»˜åˆ¶é‡åŠ›æ–¹å‘ç®­å¤´
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(leftX, leftY);
            ctx.lineTo(rightX, rightY);
            ctx.stroke();
          }
        } else if (advancedEffectType === 'storm' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶é›·æš´å¼•å¯¼
          stormClouds.forEach(cloud => {
            // ç»˜åˆ¶é›·äº‘
            const cloudGradient = ctx.createRadialGradient(
              cloud.x, cloud.y, 0,
              cloud.x, cloud.y, cloud.size
            );
            cloudGradient.addColorStop(0, `rgba(50, 50, 80, ${cloud.life * 0.6})`);
            cloudGradient.addColorStop(1, `rgba(30, 30, 50, 0)`);
            
            ctx.fillStyle = cloudGradient;
            ctx.beginPath();
            ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
            ctx.fill();
          });
          
          // ç»˜åˆ¶é—ªç”µ
          if (lightningActive) {
            const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
            if (rightHand && stormClouds.length > 0) {
              const cloud = stormClouds[0];
              const handX = rightHand.palmX * canvas.width;
              const handY = rightHand.palmY * canvas.height;
              
              ctx.strokeStyle = 'rgba(255, 255, 200, 0.9)';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(cloud.x, cloud.y);
              ctx.lineTo(handX, handY);
              ctx.stroke();
            }
          }
        } else if (advancedEffectType === 'rainbowcurl' && currentHandsDataForDraw.length >= 2) {
          // é›¶é‡åŠ›å½©è‰²å¼§çº¿ï¼ˆç²’å­æœ¬èº«ä¼šæ˜¾ç¤ºå½©è™¹è‰²ï¼Œæ— éœ€é¢å¤–ç»˜åˆ¶ï¼‰
        } else if (advancedEffectType === 'lightning' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶åŒæ‰‹é›·ç”µçƒ
          const leftHand = currentHandsDataForDraw.find(h => h.handedness === 'Left') || currentHandsDataForDraw[0];
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          
          if (leftHand && rightHand) {
            const leftX = leftHand.palmX * canvas.width;
            const leftY = leftHand.palmY * canvas.height;
            const rightX = rightHand.palmX * canvas.width;
            const rightY = rightHand.palmY * canvas.height;
            
            // è®¡ç®—é›·ç”µçƒä¸­å¿ƒç‚¹å’ŒåŠå¾„
            const ballCenterX = (leftX + rightX) / 2;
            const ballCenterY = (leftY + rightY) / 2;
            const handsDistance = Math.sqrt(Math.pow(rightX - leftX, 2) + Math.pow(rightY - leftY, 2));
            const ballRadius = Math.min(200, Math.max(50, handsDistance * 0.5));
            
            // ç»˜åˆ¶æœ€å¤–å±‚å…‰æ™•
            const outerGradient = ctx.createRadialGradient(
              ballCenterX, ballCenterY, 0,
              ballCenterX, ballCenterY, ballRadius * 1.5
            );
            outerGradient.addColorStop(0, 'rgba(200, 220, 255, 0.6)');
            outerGradient.addColorStop(0.5, 'rgba(150, 200, 255, 0.3)');
            outerGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(ballCenterX, ballCenterY, ballRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ä¸­å±‚èƒ½é‡ç¯
            for (let layer = 0; layer < 3; layer++) {
              const layerRadius = ballRadius * (0.7 + layer * 0.15);
              const layerAlpha = 0.7 - layer * 0.2;
              
              ctx.strokeStyle = `rgba(200, 220, 255, ${layerAlpha})`;
              ctx.lineWidth = 3 - layer;
              ctx.shadowBlur = 20;
              ctx.shadowColor = 'rgba(150, 200, 255, 0.8)';
              ctx.beginPath();
              ctx.arc(ballCenterX, ballCenterY, layerRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // ç»˜åˆ¶é›·ç”µçƒæ ¸å¿ƒï¼ˆå¤šå±‚æ¸å˜ï¼‰
            const coreGradient = ctx.createRadialGradient(
              ballCenterX, ballCenterY, 0,
              ballCenterX, ballCenterY, ballRadius
            );
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.3, 'rgba(200, 220, 255, 0.9)');
            coreGradient.addColorStop(0.6, 'rgba(150, 200, 255, 0.7)');
            coreGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.shadowBlur = 30;
            ctx.shadowColor = 'rgba(200, 220, 255, 1.0)';
            ctx.beginPath();
            ctx.arc(ballCenterX, ballCenterY, ballRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å†…å±‚æ ¸å¿ƒï¼ˆé«˜äº®ï¼‰
            const innerGradient = ctx.createRadialGradient(
              ballCenterX, ballCenterY, 0,
              ballCenterX, ballCenterY, ballRadius * 0.5
            );
            innerGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            innerGradient.addColorStop(1, 'rgba(200, 220, 255, 0.6)');
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(ballCenterX, ballCenterY, ballRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬ç”µå…‰ï¼ˆä»ä¸­å¿ƒå‘å¤–ï¼‰
            const rotationAngle = Date.now() * 0.01;
            for (let i = 0; i < 12; i++) {
              const angle = rotationAngle + (i / 12) * Math.PI * 2;
              const rayLength = ballRadius * 0.8;
              const rayEndX = ballCenterX + Math.cos(angle) * rayLength;
              const rayEndY = ballCenterY + Math.sin(angle) * rayLength;
              
              const rayGradient = ctx.createLinearGradient(
                ballCenterX, ballCenterY,
                rayEndX, rayEndY
              );
              rayGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
              rayGradient.addColorStop(1, 'rgba(150, 200, 255, 0)');
              
              ctx.strokeStyle = rayGradient;
              ctx.lineWidth = 3;
              ctx.shadowBlur = 15;
              ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
              ctx.beginPath();
              ctx.moveTo(ballCenterX, ballCenterY);
              ctx.lineTo(rayEndX, rayEndY);
              ctx.stroke();
            }
            
            // ç»˜åˆ¶ä¸­å¿ƒé«˜äº®ç‚¹
            ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(200, 220, 255, 1.0)';
            ctx.beginPath();
            ctx.arc(ballCenterX, ballCenterY, 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0; // é‡ç½®é˜´å½±
          }
        } else if (advancedEffectType === 'chaos' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶æ··æ²Œå¥‡ç‚¹ï¼ˆå¤§å¹…å¢å¼ºå¯è§†åŒ–æ•ˆæœï¼‰
          if (chaosSingularityX > 0 && chaosSingularityY > 0) {
            const hue = (chaosSingularityRotation * 57.3) % 360;
            
            // ç»˜åˆ¶æœ€å¤–å±‚å…‰æ™•ï¼ˆè¶…å¤§èŒƒå›´ï¼‰
            const outerGradient = ctx.createRadialGradient(
              chaosSingularityX, chaosSingularityY, 0,
              chaosSingularityX, chaosSingularityY, 300
            );
            outerGradient.addColorStop(0, `hsla(${hue}, 100%, 70%, 0.4)`);
            outerGradient.addColorStop(0.5, `hsla(${(hue + 60) % 360}, 100%, 60%, 0.2)`);
            outerGradient.addColorStop(1, `hsla(${(hue + 120) % 360}, 100%, 50%, 0)`);
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(chaosSingularityX, chaosSingularityY, 300, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ä¸­å±‚èƒ½é‡ç¯ï¼ˆå¤šå±‚ï¼‰
            for (let layer = 0; layer < 3; layer++) {
              const layerRadius = 150 + layer * 30;
              const layerAlpha = 0.6 - layer * 0.15;
              const layerHue = (hue + layer * 40) % 360;
              
              ctx.strokeStyle = `hsla(${layerHue}, 100%, 65%, ${layerAlpha})`;
              ctx.lineWidth = 4 - layer;
              ctx.beginPath();
              ctx.arc(chaosSingularityX, chaosSingularityY, layerRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // ç»˜åˆ¶å¥‡ç‚¹æ ¸å¿ƒï¼ˆå¤šå±‚æ¸å˜ï¼‰
            const coreGradient = ctx.createRadialGradient(
              chaosSingularityX, chaosSingularityY, 0,
              chaosSingularityX, chaosSingularityY, 120
            );
            coreGradient.addColorStop(0, `hsla(${hue}, 100%, 80%, 1.0)`);
            coreGradient.addColorStop(0.3, `hsla(${(hue + 30) % 360}, 100%, 70%, 0.9)`);
            coreGradient.addColorStop(0.6, `hsla(${(hue + 60) % 360}, 100%, 60%, 0.7)`);
            coreGradient.addColorStop(1, `hsla(${(hue + 90) % 360}, 100%, 50%, 0)`);
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(chaosSingularityX, chaosSingularityY, 120, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å†…å±‚æ ¸å¿ƒï¼ˆé«˜äº®ï¼‰
            const innerGradient = ctx.createRadialGradient(
              chaosSingularityX, chaosSingularityY, 0,
              chaosSingularityX, chaosSingularityY, 60
            );
            innerGradient.addColorStop(0, `hsla(${hue}, 100%, 90%, 1.0)`);
            innerGradient.addColorStop(1, `hsla(${(hue + 30) % 360}, 100%, 70%, 0.5)`);
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(chaosSingularityX, chaosSingularityY, 60, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬èƒ½é‡ç¯ï¼ˆæ›´å¤šç²’å­ï¼Œæ›´å¤§ï¼‰
            const ringAngle = chaosSingularityRotation;
            for (let i = 0; i < 16; i++) {
              const angle = ringAngle + (i / 16) * Math.PI * 2;
              const radius = 100 + Math.sin(ringAngle * 2 + i) * 20;
              const x = chaosSingularityX + Math.cos(angle) * radius;
              const y = chaosSingularityY + Math.sin(angle) * radius;
              
              const particleHue = (hue + i * 22.5) % 360;
              const particleSize = 6 + Math.sin(ringAngle * 3 + i) * 2;
              
              // ç»˜åˆ¶èƒ½é‡ç²’å­å…‰æ™•
              const particleGradient = ctx.createRadialGradient(x, y, 0, x, y, particleSize * 2);
              particleGradient.addColorStop(0, `hsla(${particleHue}, 100%, 70%, 0.9)`);
              particleGradient.addColorStop(1, `hsla(${particleHue}, 100%, 50%, 0)`);
              
              ctx.fillStyle = particleGradient;
              ctx.beginPath();
              ctx.arc(x, y, particleSize * 2, 0, Math.PI * 2);
              ctx.fill();
              
              // ç»˜åˆ¶èƒ½é‡ç²’å­æ ¸å¿ƒ
              ctx.fillStyle = `hsla(${particleHue}, 100%, 60%, 1.0)`;
              ctx.beginPath();
              ctx.arc(x, y, particleSize, 0, Math.PI * 2);
              ctx.fill();
            }
            
            // ç»˜åˆ¶èƒ½é‡å°„çº¿ï¼ˆä»ä¸­å¿ƒå‘å¤–ï¼‰
            for (let i = 0; i < 12; i++) {
              const rayAngle = ringAngle * 2 + (i / 12) * Math.PI * 2;
              const rayLength = 200 + Math.sin(ringAngle * 4 + i) * 50;
              const rayEndX = chaosSingularityX + Math.cos(rayAngle) * rayLength;
              const rayEndY = chaosSingularityY + Math.sin(rayAngle) * rayLength;
              
              const rayGradient = ctx.createLinearGradient(
                chaosSingularityX, chaosSingularityY,
                rayEndX, rayEndY
              );
              const rayHue = (hue + i * 30) % 360;
              rayGradient.addColorStop(0, `hsla(${rayHue}, 100%, 70%, 0.8)`);
              rayGradient.addColorStop(1, `hsla(${rayHue}, 100%, 50%, 0)`);
              
              ctx.strokeStyle = rayGradient;
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(chaosSingularityX, chaosSingularityY);
              ctx.lineTo(rayEndX, rayEndY);
              ctx.stroke();
            }
            
            // ç»˜åˆ¶ä¸­å¿ƒé«˜äº®ç‚¹
            ctx.fillStyle = `hsla(${hue}, 100%, 100%, 1.0)`;
            ctx.beginPath();
            ctx.arc(chaosSingularityX, chaosSingularityY, 15, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // ç»˜åˆ¶ç©ºé—´æ‰­æ›²æ•ˆæœå¯è§†åŒ–
      if (spaceEffectType && !isHandsClosing) {
        const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
        
        if (spaceEffectType === 'blackhole' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶è™«æ´å¸å¼•æ•ˆæœï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼šæ›´å¤§æ›´é»‘ï¼‰
          if (blackHoleX > 0 && blackHoleY > 0 && blackHoleIntensity > 0) {
            const radius = 120 + blackHoleIntensity * 150; // å¤§å¹…å¢åŠ è™«æ´åŠå¾„ï¼ˆåŸæ¥60-140ï¼Œç°åœ¨120-270ï¼‰
            
            // ç»˜åˆ¶è™«æ´æœ€å¤–å±‚å…‰æ™•ï¼ˆæ·±ç´«è‰²ï¼Œæ›´å¤§èŒƒå›´ï¼‰
            const outerGradient = ctx.createRadialGradient(
              blackHoleX, blackHoleY, 0,
              blackHoleX, blackHoleY, radius * 1.5
            );
            outerGradient.addColorStop(0, `rgba(30, 0, 60, ${blackHoleIntensity * 0.4})`);
            outerGradient.addColorStop(0.5, `rgba(50, 0, 100, ${blackHoleIntensity * 0.3})`);
            outerGradient.addColorStop(1, `rgba(70, 0, 120, 0)`);
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(blackHoleX, blackHoleY, radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶è™«æ´ä¸­å±‚ï¼ˆæ·±ç´«è‰²å…‰æ™•ï¼Œå¢å¼ºä¸é€æ˜åº¦ï¼‰
            const gradient = ctx.createRadialGradient(
              blackHoleX, blackHoleY, 0,
              blackHoleX, blackHoleY, radius
            );
            gradient.addColorStop(0, `rgba(20, 0, 40, ${blackHoleIntensity * 0.95})`);
            gradient.addColorStop(0.3, `rgba(30, 0, 60, ${blackHoleIntensity * 0.8})`);
            gradient.addColorStop(0.6, `rgba(50, 0, 100, ${blackHoleIntensity * 0.6})`);
            gradient.addColorStop(1, `rgba(100, 0, 150, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(blackHoleX, blackHoleY, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶è™«æ´æ ¸å¿ƒï¼ˆçº¯é»‘è‰²ï¼Œæ›´å¤§ï¼‰
            const coreRadius = 40 + blackHoleIntensity * 60; // å¤§å¹…å¢åŠ æ ¸å¿ƒåŠå¾„ï¼ˆåŸæ¥15-40ï¼Œç°åœ¨40-100ï¼‰
            ctx.fillStyle = `rgba(0, 0, 0, ${Math.min(1, blackHoleIntensity * 1.2)})`; // ç¡®ä¿å®Œå…¨ä¸é€æ˜
            ctx.beginPath();
            ctx.arc(blackHoleX, blackHoleY, coreRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶å†…å±‚é»‘è‰²ç¯ï¼ˆå¢å¼ºé»‘æ´æ•ˆæœï¼‰
            const innerRingRadius = coreRadius * 1.3;
            ctx.strokeStyle = `rgba(0, 0, 0, ${blackHoleIntensity * 0.9})`;
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(blackHoleX, blackHoleY, innerRingRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶æ—‹è½¬çš„ç²’å­ç¯ï¼ˆæ›´å¤šç²’å­ï¼Œæ›´å¤§ï¼‰
            const ringAngle = Date.now() * 0.015; // åŠ å¿«æ—‹è½¬
            for (let i = 0; i < 6; i++) { // å¢åŠ ç²’å­æ•°é‡
              const ringRadius = radius * 0.5 + i * 15;
              const ringX = blackHoleX + Math.cos(ringAngle + i * Math.PI / 3) * ringRadius;
              const ringY = blackHoleY + Math.sin(ringAngle + i * Math.PI / 3) * ringRadius;
              
              ctx.fillStyle = `rgba(100, 0, 200, ${blackHoleIntensity * 0.9})`;
              ctx.beginPath();
              ctx.arc(ringX, ringY, 6, 0, Math.PI * 2); // å¢å¤§ç²’å­å°ºå¯¸
              ctx.fill();
            }
          }
        } else if (spaceEffectType === 'portal' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶ç©ºé—´é—¨æ•ˆæœï¼ˆå¢å¼ºè§†è§‰æ•ˆæœï¼‰
          if (portalCenterX > 0 && portalCenterY > 0 && portalRadius > 0) {
            // ç»˜åˆ¶ä¼ é€é—¨æœ€å¤–å±‚å…‰æ™•
            const outerGradient = ctx.createRadialGradient(
              portalCenterX, portalCenterY, 0,
              portalCenterX, portalCenterY, portalRadius * 1.5
            );
            outerGradient.addColorStop(0, 'rgba(100, 50, 200, 0.3)');
            outerGradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, portalRadius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶ä¼ é€é—¨å¤–å±‚åœ†ç¯ï¼ˆå¢å¼ºå®½åº¦å’Œäº®åº¦ï¼‰
            ctx.strokeStyle = `rgba(150, 100, 255, 1.0)`;
            ctx.lineWidth = 6; // å¢åŠ çº¿å®½
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, portalRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶ä¼ é€é—¨ä¸­å±‚åœ†ç¯
            ctx.strokeStyle = `rgba(200, 150, 255, 0.9)`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, portalRadius * 0.85, 0, Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶ä¼ é€é—¨å†…å±‚åœ†ç¯ï¼ˆæ—‹è½¬ï¼Œå¢å¼ºäº®åº¦ï¼‰
            ctx.strokeStyle = `rgba(200, 150, 255, 0.8)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, portalRadius * 0.7, portalRotation, portalRotation + Math.PI * 2);
            ctx.stroke();
            
            // ç»˜åˆ¶ä¼ é€é—¨ä¸­å¿ƒï¼ˆèƒ½é‡æ ¸å¿ƒï¼Œå¢å¼ºäº®åº¦ï¼‰
            const coreGradient = ctx.createRadialGradient(
              portalCenterX, portalCenterY, 0,
              portalCenterX, portalCenterY, portalRadius * 0.4
            );
            coreGradient.addColorStop(0, 'rgba(255, 200, 255, 1.0)');
            coreGradient.addColorStop(0.5, 'rgba(200, 150, 255, 0.8)');
            coreGradient.addColorStop(1, 'rgba(100, 50, 200, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(portalCenterX, portalCenterY, portalRadius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬çš„èƒ½é‡ç²’å­ï¼ˆæ›´å¤šç²’å­ï¼Œæ›´å¤§ï¼‰
            const particleAngle = Date.now() * 0.02 + portalRotation; // åŠ å¿«æ—‹è½¬
            for (let i = 0; i < 12; i++) { // å¢åŠ ç²’å­æ•°é‡
              const angle = particleAngle + (i / 12) * Math.PI * 2;
              const px = portalCenterX + Math.cos(angle) * portalRadius;
              const py = portalCenterY + Math.sin(angle) * portalRadius;
              
              ctx.fillStyle = `rgba(200, 150, 255, 1.0)`;
              ctx.beginPath();
              ctx.arc(px, py, 5, 0, Math.PI * 2); // å¢å¤§ç²’å­å°ºå¯¸
              ctx.fill();
            }
          }
        } else if (spaceEffectType === 'freeze') {
          // ç²’å­å†»ç»“æ•ˆæœä¸éœ€è¦ç‰¹æ®Šå¯è§†åŒ–ï¼Œç²’å­æœ¬èº«ä¼šå˜è“
        } else if (spaceEffectType === 'rewind' && currentHandsDataForDraw.length >= 2) {
          // ç»˜åˆ¶æ—¶é—´å€’æµæ•ˆæœï¼ˆå¢å¼ºç»¿è‰²å…‰æ™•å’Œç®­å¤´ï¼‰
          const rightHand = currentHandsDataForDraw.find(h => h.handedness === 'Right') || currentHandsDataForDraw[1];
          if (rightHand && rewindActive) {
            const handX = rightHand.palmX * canvas.width;
            const handY = rightHand.palmY * canvas.height;
            
            // ç»˜åˆ¶æ—¶é—´å€’æµæœ€å¤–å±‚å…‰æ™•ï¼ˆæ›´å¤§èŒƒå›´ï¼‰
            const outerGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 300
            );
            outerGradient.addColorStop(0, 'rgba(0, 255, 150, 0.2)');
            outerGradient.addColorStop(1, 'rgba(0, 200, 200, 0)');
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 300, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—¶é—´å€’æµå†…å±‚å…‰æ™•ï¼ˆå¢å¼ºäº®åº¦ï¼‰
            const rewindGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 250
            );
            rewindGradient.addColorStop(0, 'rgba(0, 255, 100, 0.6)');
            rewindGradient.addColorStop(0.5, 'rgba(0, 255, 150, 0.4)');
            rewindGradient.addColorStop(1, 'rgba(0, 200, 150, 0)');
            
            ctx.fillStyle = rewindGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 250, 0, Math.PI * 2);
            ctx.fill();
            
            // ç»˜åˆ¶æ—‹è½¬çš„æ—¶é—´ç®­å¤´ï¼ˆæ›´å¤šç®­å¤´ï¼Œæ›´å¤§æ›´äº®ï¼‰
            const arrowAngle = Date.now() * 0.015; // åŠ å¿«æ—‹è½¬
            for (let i = 0; i < 6; i++) { // å¢åŠ ç®­å¤´æ•°é‡
              const angle = arrowAngle + (i / 6) * Math.PI * 2;
              const arrowX = handX + Math.cos(angle) * 100;
              const arrowY = handY + Math.sin(angle) * 100;
              
              // ç»˜åˆ¶ç®­å¤´ä¸»ä½“
              ctx.strokeStyle = `rgba(0, 255, 150, 1.0)`;
              ctx.lineWidth = 5; // å¢åŠ çº¿å®½
              ctx.beginPath();
              ctx.moveTo(arrowX, arrowY);
              ctx.lineTo(arrowX - Math.cos(angle) * 30, arrowY - Math.sin(angle) * 30);
              ctx.stroke();
              
              // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
              ctx.fillStyle = `rgba(0, 255, 150, 1.0)`;
              ctx.beginPath();
              ctx.moveTo(arrowX, arrowY);
              ctx.lineTo(arrowX - Math.cos(angle - 0.3) * 15, arrowY - Math.sin(angle - 0.3) * 15);
              ctx.lineTo(arrowX - Math.cos(angle + 0.3) * 15, arrowY - Math.sin(angle + 0.3) * 15);
              ctx.closePath();
              ctx.fill();
            }
            
            // ç»˜åˆ¶ä¸­å¿ƒèƒ½é‡æ ¸å¿ƒ
            const coreGradient = ctx.createRadialGradient(
              handX, handY, 0,
              handX, handY, 40
            );
            coreGradient.addColorStop(0, 'rgba(0, 255, 200, 1.0)');
            coreGradient.addColorStop(1, 'rgba(0, 200, 150, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(handX, handY, 40, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // ç»˜åˆ¶æ‰‹æŒèŒƒå›´ä¸éª¨æ¶ï¼ˆéçƒä½“æ¨¡å¼ä¸‹å±•ç¤ºï¼‰
      // æ”¯æŒå¤šåªæ‰‹ï¼Œç»˜åˆ¶æ‰€æœ‰æ‰‹
      const currentHandsDataForDraw = (typeof handsData !== 'undefined' && Array.isArray(handsData)) ? handsData : [];
      if (currentHandsDataForDraw.length > 0 && !isSphereMode) {
        // éå†æ‰€æœ‰æ‰‹è¿›è¡Œç»˜åˆ¶
        for (let handIdx = 0; handIdx < currentHandsDataForDraw.length; handIdx++) {
          const handData = currentHandsDataForDraw[handIdx];
        const px = handData.palmX * canvas.width;
        const py = handData.palmY * canvas.height;
          const radius = 400 + handSpeed * 80;

        // ç»˜åˆ¶å½±å“èŒƒå›´
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);

        const colors = {
          open: 'rgba(150, 100, 255, 0.2)',
          five: 'rgba(150, 100, 255, 0.2)',
          closed: 'rgba(255, 100, 100, 0.2)',
          pointing: 'rgba(255, 150, 50, 0.2)',
          two: 'rgba(255, 200, 0, 0.3)',
          one: 'rgba(255, 100, 150, 0.3)',
          four: 'rgba(255, 180, 50, 0.3)',
        };

        ctx.strokeStyle =
          colors[handData.gesture] || 'rgba(100, 100, 255, 0.2)';
        ctx.lineWidth = 2 + handSpeed * 2;
        ctx.stroke();

        // ç»˜åˆ¶èƒ½é‡æ³¢ï¼ˆå¿«é€Ÿç§»åŠ¨æ—¶ï¼‰
        if (handSpeed > 0.3) {
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(px, py, radius + i * 30, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 - i * 0.1})`;
        ctx.lineWidth = 2;
            ctx.stroke();
          }
        }

        // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶ï¼ˆæ ¹æ®æ‰‹åŠ¿æ”¹å˜é¢œè‰²ï¼‰
        const skeletonColors = {
          open: 'rgba(150, 100, 255, 0.8)',
          five: 'rgba(150, 100, 255, 0.8)',
          closed: 'rgba(255, 100, 100, 0.8)',
          pointing: 'rgba(255, 150, 50, 0.8)',
          two: 'rgba(255, 200, 0, 0.9)',
          one: 'rgba(255, 100, 150, 0.9)',
          four: 'rgba(255, 180, 50, 0.9)',
        };
        ctx.strokeStyle = skeletonColors[handData.gesture] || 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2 + handSpeed;

        const connections = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 4],
          [0, 5],
          [5, 6],
          [6, 7],
          [7, 8],
          [5, 9],
          [9, 10],
          [10, 11],
          [11, 12],
          [9, 13],
          [13, 14],
          [14, 15],
          [15, 16],
          [13, 17],
          [17, 18],
          [18, 19],
          [19, 20],
          [0, 17],
        ];

        connections.forEach(([start, end]) => {
          const startPoint = handData.landmarks[start];
          const endPoint = handData.landmarks[end];
          ctx.beginPath();
          ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
          ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
          ctx.stroke();
        });

        // æ¯”2æ‰‹åŠ¿ï¼ˆåŒ…æ‹¬èƒœåˆ©æ‰‹åŠ¿ï¼‰ç‰¹æ®Šæ•ˆæœï¼šåœ¨æ‰‹æŒ‡å‘¨å›´ç»˜åˆ¶å…‰ç¯
        if (handData.gesture === 'two' && handData.landmarks) {
          const indexTip = handData.landmarks[8];
          const middleTip = handData.landmarks[12];
          
          [indexTip, middleTip].forEach((tip) => {
            const tipX = tip.x * canvas.width;
            const tipY = tip.y * canvas.height;
            
            // ç»˜åˆ¶å¤šå±‚å…‰ç¯
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.arc(tipX, tipY, 15 + i * 10, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 - i * 0.15})`;
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        }

        } // å…³é—­å¤šåªæ‰‹å¾ªç¯
      }

      // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
      // ç²’å­æ›´æ–°å‡½æ•°ç›´æ¥ä½¿ç”¨å…¨å±€çš„ handsData æ•°ç»„
      particles.forEach((particle) => {
        particle.update();
        particle.draw();
      });

      // ç²’å­ä¹‹é—´çš„è¿çº¿ï¼ˆæ§åˆ¶æ•°é‡ï¼Œå‡è½»æ€§èƒ½å‹åŠ›ï¼‰
      particles.forEach((p1, i) => {
        // åªå¯¹å‰ä¸€éƒ¨åˆ†ç²’å­ç”»è¿çº¿ï¼Œé¿å… O(N^2) å¼€é”€
        if (i > 300) return;
        particles.slice(i + 1, i + 4).forEach((p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 80) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            
            // æ ¹æ®æ‰‹åŠ¿å’Œå½©è™¹æ¨¡å¼æ”¹å˜è¿çº¿é¢œè‰²
            let hue = 200;
            if (handData && rainbowMode) {
              hue = (rainbowHue + dist * 2) % 360;
            } else if (handData) {
              const gestureHues = {
                open: 280,
                five: 280,
                closed: 0,
                pointing: 30,
                two: 60,
              };
              hue = gestureHues[handData.gesture] || 200;
            }
            
            ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${
              (1 - dist / 100) * 0.4
            })`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        });
      });

      requestAnimationFrame(animate);
    }

    animate();
 
    document
      .getElementById('particleCount')
      .addEventListener('input', (e) => {
        particleCount = parseInt(e.target.value, 10);
        document.getElementById('particleCountValue').textContent =
          particleCount;
        initParticles();
      });

    document.getElementById('force').addEventListener('input', (e) => {
      forceMultiplier = parseFloat(e.target.value);
      document.getElementById('forceValue').textContent =
        forceMultiplier.toFixed(1);
    });

    document.getElementById('trailMode').addEventListener('change', (e) => {
      trailMode = e.target.checked;
    });

    document.getElementById('rainbowMode').addEventListener('change', (e) => {
      rainbowMode = e.target.checked;
    });

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initParticles();
    });
  </script>
</body>
</html>


