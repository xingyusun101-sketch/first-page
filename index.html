<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æ‰‹åŠ¿è¯†åˆ«ç²’å­ç³»ç»Ÿ</title>

  <!-- MediaPipe ä¾èµ– -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #0a0a1e;
      font-family: Arial, sans-serif;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #video {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 200px;
      height: 150px;
      border: 2px solid #4a90e2;
      border-radius: 8px;
      transform: scaleX(-1);
      z-index: 10;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      padding: 12px 14px;
      border-radius: 10px;
      color: #fff;
      z-index: 10;
      max-width: 270px;
    }

    #controls h3 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 14px;
      margin-bottom: 8px;
      color: #4a90e2;
    }

    #controlsToggle {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid #4a90e2;
      background: rgba(0, 0, 0, 0.6);
      color: #4a90e2;
      cursor: pointer;
      white-space: nowrap;
    }

    #controlsToggle:hover {
      background: rgba(74, 144, 226, 0.15);
    }

    #controls.collapsed {
      padding: 6px 10px;
      max-width: 190px;
    }

    #controls.collapsed h3 {
      margin-bottom: 0;
      font-size: 13px;
    }

    #controls.collapsed #controlsContent {
      display: none;
    }

    .control-group {
      margin-bottom: 12px;
    }

    .control-group label {
      display: block;
      font-size: 12px;
      margin-bottom: 5px;
      color: #aaa;
    }

    .control-group input[type="range"] {
      width: 100%;
    }

    .status {
      padding: 8px;
      border-radius: 5px;
      font-size: 12px;
      margin-bottom: 10px;
    }

    .status.waiting {
      background: rgba(255, 165, 0, 0.2);
      border: 1px solid orange;
    }

    .status.ready {
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid lime;
    }

    .gesture-info {
      background: rgba(100, 100, 255, 0.2);
      padding: 8px;
      border-radius: 5px;
      font-size: 11px;
      margin-top: 10px;
      line-height: 1.5;
    }

    h3 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #4a90e2;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <video id="video" autoplay playsinline></video>

    <div id="controls">
      <h3>
        ğŸ® æ‰‹åŠ¿æ§åˆ¶ç²’å­ç³»ç»Ÿ
        <button id="controlsToggle" type="button">æ”¶èµ·é¢æ¿</button>
      </h3>

      <div id="controlsContent">
        <div id="status" class="status waiting">
          æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...
        </div>

        <div id="speedIndicator" style="font-size: 10px; color: #888; margin-bottom: 10px; display: none;">
          ç§»åŠ¨é€Ÿåº¦: <span id="speedValue">0</span>
        </div>

        <div class="control-group">
          <label>
            ç²’å­æ•°é‡:
            <span id="particleCountValue">600</span>
          </label>
          <input
            type="range"
            id="particleCount"
            min="200"
            max="1200"
            value="600"
          />
        </div>

        <div class="control-group">
          <label>
            äº¤äº’å¼ºåº¦:
            <span id="forceValue">1.0</span>
          </label>
          <input
            type="range"
            id="force"
            min="0.5"
            max="3"
            step="0.1"
            value="1.0"
          />
        </div>

        <div class="control-group">
          <label>
            <input type="checkbox" id="trailMode" checked />
            æ‹–å°¾æ•ˆæœ
          </label>
        </div>

        <div class="control-group">
          <label>
            <input type="checkbox" id="rainbowMode" />
            å½©è™¹æ¨¡å¼
          </label>
        </div>

        <div class="gesture-info">
          <strong>æ‰‹åŠ¿è¯´æ˜ï¼š</strong><br />
          âœ‹ å¼ å¼€æ‰‹æŒ - å¸å¼•ç²’å­<br />
          âœŠ æ¡ç´§æ‹³å¤´ - æ’æ–¥ç²’å­<br />
          â˜ï¸ ä¼¸å‡ºé£ŸæŒ‡ - å‘å°„ç²’å­<br />
          ğŸ¤ æåˆæ‰‹åŠ¿ - å½¢æˆæ—‹è½¬çƒä½“ï¼ˆåœ°çƒï¼‰<br />
          âœŒï¸ èƒœåˆ©æ‰‹åŠ¿ - ç²’å­çˆ†ç‚¸<br />
          ğŸ‘Œ OKæ‰‹åŠ¿ - ç²’å­æ—‹è½¬<br />
          â˜ï¸ æ¯” 1 æ‰‹åŠ¿ - æ‹¼æˆæ–‡å­—
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('video');
    const statusDiv = document.getElementById('status');
    const controls = document.getElementById('controls');
    const controlsContent = document.getElementById('controlsContent');
    const controlsToggle = document.getElementById('controlsToggle');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [];
    let handData = null;
    let previousHandData = null;
    let particleCount = 600;
    let forceMultiplier = 1.0;
    let trailMode = true;
    let rainbowMode = false;
    let rainbowHue = 0;
    let explosions = [];
    let previousPalmX = 0;
    let previousPalmY = 0;
    let handSpeed = 0;
    let textTargets = []; // æ–‡å­—ç›®æ ‡ä½ç½®
    let isFormingText = false; // æ˜¯å¦æ­£åœ¨å½¢æˆæ–‡å­—
    let isSphereMode = false; // æ˜¯å¦å¤„äºç«‹ä½“çƒæ¨¡å¼
    let sphereRotation = 0; // çƒä½“æ—‹è½¬è§’åº¦

    // ç®€å•åˆ¤æ–­æ˜¯å¦ä¸ºæ‰‹æœºè®¾å¤‡ï¼Œç”¨äºåšä¸€äº›è‡ªé€‚åº”è°ƒæ•´
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    // çˆ†ç‚¸æ•ˆæœç±»
    class Explosion {
      constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.particles = [];
        this.color = color;
        for (let i = 0; i < 20; i++) {
          this.particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1,
            size: Math.random() * 4 + 2,
          });
        }
      }

      update() {
        this.particles = this.particles.filter((p) => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.95;
          p.vy *= 0.95;
          p.life -= 0.02;
          return p.life > 0;
        });
        return this.particles.length > 0;
      }

      draw() {
        this.particles.forEach((p) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.globalAlpha = p.life;
          ctx.fill();
          ctx.globalAlpha = 1;
        });
      }
    }

    // ç²’å­ç±»
    class Particle {
      constructor() {
        this.reset();
        this.trail = [];
        this.maxTrailLength = 8;
        this.life = 1;
        this.maxLife = 1;
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.size = Math.random() * 2 + 0.8; // å‡å°ç²’å­å¤§å°ï¼Œè®©æ›´å¤šç²’å­å¯è§
        this.hue = Math.random() * 60 + 180;
        this.trail = [];
        this.life = 1;
        this.maxLife = 1;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.targetX = null; // ç›®æ ‡Xä½ç½®ï¼ˆç”¨äºæ–‡å­—å½¢æˆï¼‰
        this.targetY = null; // ç›®æ ‡Yä½ç½®ï¼ˆç”¨äºæ–‡å­—å½¢æˆï¼‰
        this.sphereLat = null; // çƒä½“æ¨¡å¼ï¼šçº¬åº¦
        this.sphereLon = null; // çƒä½“æ¨¡å¼ï¼šç»åº¦
      }

      update(hands) {
        // è®°å½•è½¨è¿¹
        if (trailMode) {
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.maxTrailLength) {
            this.trail.shift();
          }
        }

        // å¦‚æœå¤„äºç«‹ä½“çƒæ¨¡å¼ï¼Œä¼˜å…ˆæ²¿çƒä½“è½¨é“è¿åŠ¨
        if (isSphereMode && this.sphereLat !== null && this.sphereLon !== null) {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          const radius = Math.min(canvas.width, canvas.height) * 0.25;

          // 3D çƒåæ ‡
          const lat = this.sphereLat;
          const lon = this.sphereLon + sphereRotation;

          const x3 = Math.cos(lat) * Math.cos(lon);
          const y3 = Math.sin(lat);
          const z3 = Math.cos(lat) * Math.sin(lon);

          // ç®€å•é€è§†ç¼©æ”¾ï¼ˆz è¶Šå¤§è¶Šé å‰ï¼‰
          const depth = (z3 + 1) / 2; // 0~1
          const scale = 0.3 + depth * 0.7;

          const targetX = cx + x3 * radius * scale * 1.2;
          const targetY = cy + y3 * radius * scale * 1.2;

          const dxSphere = targetX - this.x;
          const dySphere = targetY - this.y;
          const distSphere = Math.sqrt(dxSphere * dxSphere + dySphere * dySphere);

          const sphereForce = Math.min(0.25, distSphere / 100) * 0.25;
          this.vx += dxSphere * sphereForce;
          this.vy += dySphere * sphereForce;

          this.vx *= 0.9;
          this.vy *= 0.9;

          this.x += this.vx;
          this.y += this.vy;

          // çƒä½“æ¨¡å¼ä¸‹çš„é¢œè‰²ï¼šæ¨¡æ‹Ÿåœ°çƒè“ç»¿è‰²
          const baseHue = 200 + depth * 40; // 200~240
          this.hue = rainbowMode ? (rainbowHue + depth * 60) % 360 : baseHue;
          this.size = 1.5 + depth * 2; // å‰æ™¯ç²’å­æ›´å¤§

          return;
        }

        // è¾¹ç•Œåå¼¹
        if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

        this.x = Math.max(0, Math.min(canvas.width, this.x));
        this.y = Math.max(0, Math.min(canvas.height, this.y));

        // æ‰‹åŠ¿å½±å“
        if (hands) {
          const palmX = hands.palmX * canvas.width;
          const palmY = hands.palmY * canvas.height;
          const dx = palmX - this.x;
          const dy = palmY - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const radius = 400 + handSpeed * 80; // æ‰©å¤§å½±å“èŒƒå›´ï¼Œé€Ÿåº¦å½±å“èŒƒå›´

          if (dist < radius) {
            const force = ((radius - dist) / radius) * forceMultiplier * (1 + handSpeed * 0.5);
            const angle = Math.atan2(dy, dx);

            // æ ¹æ®è·ç¦»åŠ¨æ€è°ƒæ•´ç²’å­å¤§å°
            this.size = Math.max(0.8, Math.min(4, 1.5 + (radius - dist) / radius * 2.5));

            if (hands.gesture === 'open') {
              // å¼ å¼€æ‰‹æŒ - å¸å¼•ï¼ˆå¢å¼ºæ•ˆæœï¼‰
              const attractForce = force * (1.2 + (radius - dist) / radius * 0.8); // è·ç¦»è¶Šè¿‘å¸å¼•åŠ›è¶Šå¼º
              this.vx += Math.cos(angle) * attractForce;
              this.vy += Math.sin(angle) * attractForce;
              this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 280;
            } else if (hands.gesture === 'closed') {
              // æ¡æ‹³ - æ’æ–¥
              this.vx -= Math.cos(angle) * force * 1.2;
              this.vy -= Math.sin(angle) * force * 1.2;
              this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 0;
            } else if (hands.gesture === 'pointing') {
              // é£ŸæŒ‡ - å‘å°„
              this.vx -= Math.cos(angle) * force * 2;
              this.vy -= Math.sin(angle) * force * 2;
              this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 30;
            } else if (hands.gesture === 'victory') {
              // èƒœåˆ©æ‰‹åŠ¿ - çˆ†ç‚¸æ•ˆæœ + è·Ÿéšæ‰‹æŒ‡
              const explosionForce = force * 3;
              this.vx += (Math.random() - 0.5) * explosionForce;
              this.vy += (Math.random() - 0.5) * explosionForce;
              
              // è·Ÿéšé£ŸæŒ‡å’Œä¸­æŒ‡
              if (hands.landmarks && hands.landmarks[8] && hands.landmarks[12]) {
                const indexX = hands.landmarks[8].x * canvas.width;
                const indexY = hands.landmarks[8].y * canvas.height;
                const middleX = hands.landmarks[12].x * canvas.width;
                const middleY = hands.landmarks[12].y * canvas.height;
                const avgX = (indexX + middleX) / 2;
                const avgY = (indexY + middleY) / 2;
                
                const followDx = avgX - this.x;
                const followDy = avgY - this.y;
                const followDist = Math.sqrt(followDx * followDx + followDy * followDy);
                
                if (followDist < 150) {
                  this.vx += followDx * 0.02;
                  this.vy += followDy * 0.02;
                }
              }
              
              this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : (dist * 2) % 360;
            } else if (hands.gesture === 'ok') {
              // OKæ‰‹åŠ¿ - æ—‹è½¬
              this.rotation += 0.1;
              const rotX = Math.cos(this.rotation) * (this.x - palmX) - Math.sin(this.rotation) * (this.y - palmY) + palmX;
              const rotY = Math.sin(this.rotation) * (this.x - palmX) + Math.cos(this.rotation) * (this.y - palmY) + palmY;
              this.vx += (rotX - this.x) * 0.1;
              this.vy += (rotY - this.y) * 0.1;
              this.hue = rainbowMode ? (rainbowHue + dist * 2) % 360 : 200;
            }
          }
        }

        // æ¯” 1 æ‰‹åŠ¿å½¢æˆæ–‡å­—æ—¶ï¼Œå¼ºåˆ¶ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼ˆä¸å—æ‰‹åŠ¿å½±å“èŒƒå›´é™åˆ¶ï¼‰
        if (isFormingText && this.targetX !== null && this.targetY !== null) {
          const targetDx = this.targetX - this.x;
          const targetDy = this.targetY - this.y;
          const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
          
          if (targetDist > 2) {
            // å¼ºå¸å¼•åŠ›ï¼Œè®©ç²’å­å¿«é€Ÿç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
            const textForce = Math.min(0.3, targetDist / 100) * 0.25;
            this.vx += targetDx * textForce;
            this.vy += targetDy * textForce;
            this.vx *= 0.92; // å¢åŠ é˜»å°¼
            this.vy *= 0.92;
            
            // æ›´æ–°é¢œè‰²å’Œå¤§å°
            // å‚ä¸æ‹¼å­—çš„ç²’å­ç”¨åç²‰è‰²åŒºåˆ†
            this.hue = rainbowMode ? (rainbowHue + targetDist * 2) % 360 : 320;
            this.size = Math.max(1.8, Math.min(3.5, 2.5 + (100 - targetDist) / 100 * 1));
          } else {
            // å·²ç»åˆ°è¾¾ç›®æ ‡ä½ç½®
            this.x = this.targetX;
            this.y = this.targetY;
            this.vx *= 0.7;
            this.vy *= 0.7;
            this.hue = rainbowMode ? rainbowHue % 360 : 320;
            this.size = 2.5;
          }
        }

        // é˜»å°¼ï¼ˆåœ¨æ‰‹éƒ¨é™„è¿‘æ—¶å¢åŠ é˜»å°¼ï¼Œè®©ç²’å­æ›´å®¹æ˜“èšé›†ï¼‰
        let damping = 0.98;
        if (hands) {
          const palmX = hands.palmX * canvas.width;
          const palmY = hands.palmY * canvas.height;
          const dx = palmX - this.x;
          const dy = palmY - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 150 && hands.gesture === 'open') {
            damping = 0.95; // åœ¨æ‰‹éƒ¨é™„è¿‘æ—¶å¢åŠ é˜»å°¼
          }
        }
        this.vx *= damping;
        this.vy *= damping;

        this.x += this.vx;
        this.y += this.vy;

        // æ— æ‰‹åŠ¿æ—¶ç¼“æ…¢å˜å›åŸºè‰²
        if (!hands) {
          this.hue += (200 - this.hue) * 0.05;
          this.size = Math.max(1, this.size * 0.99);
        }
      }

      draw() {
        // ç»˜åˆ¶æ‹–å°¾
        if (trailMode && this.trail.length > 1) {
          ctx.save();
          ctx.shadowBlur = 0; // å…³é—­é˜´å½±ä»¥å‡è½»æ‹–å°¾çš„æ€§èƒ½å‹åŠ›
          ctx.beginPath();
          ctx.moveTo(this.trail[0].x, this.trail[0].y);
          for (let i = 1; i < this.trail.length; i++) {
            const alpha = i / this.trail.length * 0.5;
            ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;
            ctx.lineWidth = this.size * (i / this.trail.length);
            ctx.lineTo(this.trail[i].x, this.trail[i].y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.trail[i].x, this.trail[i].y);
          }
          ctx.restore();
        }

        // ç»˜åˆ¶ç²’å­
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${this.hue}, 70%, 60%, 0.8)`;
        ctx.fill();
        ctx.shadowBlur = 8; // é™ä½é˜´å½±æ¨¡ç³ŠåŠå¾„ï¼Œæå‡æ€§èƒ½
        ctx.shadowColor = `hsla(${this.hue}, 70%, 60%, 0.6)`;
        
        // å¤–åœˆå…‰æ™•
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
        ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, 0.3)`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    }

    // åˆå§‹åŒ–ç²’å­
    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle());
      }
    }

    // æ ¹æ®è®¾å¤‡ç±»å‹è‡ªé€‚åº”åˆå§‹ç²’å­æ•°é‡å’Œæ»‘å—èŒƒå›´ï¼ˆæ‰‹æœºä¸Šé»˜è®¤å°‘ä¸€ç‚¹ï¼Œä¿è¯æµç•…ï¼‰
    (function adaptForDevice() {
      const particleSlider = document.getElementById('particleCount');
      const particleValueSpan = document.getElementById('particleCountValue');
      if (!particleSlider || !particleValueSpan) return;

      if (isMobile) {
        particleCount = 450;
        particleSlider.min = 150;
        particleSlider.max = 900;
        particleSlider.value = particleCount;
        particleValueSpan.textContent = particleCount;

        // æ‰‹æœºé»˜è®¤æŠ˜å æ§åˆ¶é¢æ¿ï¼Œåªæ˜¾ç¤ºæ ‡é¢˜å’ŒæŒ‰é’®
        if (controls && controlsToggle && controlsContent) {
          controls.classList.add('collapsed');
          controlsToggle.textContent = 'å±•å¼€é¢æ¿';
        }
      } else {
        particleCount = 600;
        particleSlider.min = 200;
        particleSlider.max = 1200;
        particleSlider.value = particleCount;
        particleValueSpan.textContent = particleCount;
      }
    })();

    // æ§åˆ¶é¢æ¿å±•å¼€ / æ”¶èµ·
    if (controls && controlsToggle && controlsContent) {
      controlsToggle.addEventListener('click', () => {
        const collapsed = controls.classList.toggle('collapsed');
        controlsToggle.textContent = collapsed ? 'å±•å¼€é¢æ¿' : 'æ”¶èµ·é¢æ¿';
      });
    }

    initParticles();

    // ç”Ÿæˆæ–‡å­—ç²’å­ä½ç½®
    function generateTextParticles(text) {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      
      // ä½¿ç”¨æ”¯æŒä¸­æ–‡çš„å­—ä½“ï¼Œå¹¶æ ¹æ®å½“å‰ç”»å¸ƒå¤§å°è‡ªé€‚åº”å­—å·
      const baseSize = Math.min(canvas.width, canvas.height);
      // æ‰‹æœºä¸Šå­—ç¨å¾®å°ä¸€ç‚¹ï¼Œé¿å…è¶…å‡ºå±å¹•
      const fontSize = baseSize * (isMobile ? 0.22 : 0.28);

      tempCtx.fillStyle = '#ffffff';
      tempCtx.font = `bold ${fontSize}px "Microsoft YaHei", "SimHei", Arial, sans-serif`;
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      
      // åœ¨canvasä¸­å¿ƒç»˜åˆ¶æ–‡å­—
      tempCtx.fillText(text, canvas.width / 2, canvas.height / 2);
      
      // è·å–åƒç´ æ•°æ®
      const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const positions = [];
      
      // é‡‡æ ·åƒç´ ï¼Œè·å–æ–‡å­—ä½ç½®ï¼ˆæ¯éš”å‡ ä¸ªåƒç´ é‡‡æ ·ä¸€æ¬¡ï¼Œé¿å…ç²’å­è¿‡å¤šï¼‰
      const step = 2; // å‡å°é‡‡æ ·æ­¥é•¿ï¼Œè®©æ–‡å­—æ›´æ¸…æ™°
      for (let y = 0; y < canvas.height; y += step) {
        for (let x = 0; x < canvas.width; x += step) {
          const index = (y * canvas.width + x) * 4;
          // æ£€æŸ¥åƒç´ æ˜¯å¦åœ¨æ–‡å­—èŒƒå›´å†…ï¼ˆalpha > 0ï¼‰
          if (data[index + 3] > 128) {
            positions.push({ x, y });
          }
        }
      }
      
      // å¦‚æœä½ç½®å¤ªå°‘ï¼Œå¢åŠ é‡‡æ ·å¯†åº¦
      if (positions.length < particleCount * 0.5) {
        const step2 = 1;
        for (let y = 0; y < canvas.height; y += step2) {
          for (let x = 0; x < canvas.width; x += step2) {
            const index = (y * canvas.width + x) * 4;
            if (data[index + 3] > 128) {
              // é¿å…é‡å¤æ·»åŠ 
              const exists = positions.some(p => Math.abs(p.x - x) < 2 && Math.abs(p.y - y) < 2);
              if (!exists) {
                positions.push({ x, y });
              }
            }
          }
        }
      }
      
      return positions;
    }

    // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
    function detectGesture(landmarks) {
      const fingerTips = [8, 12, 16, 20];
      const fingerBases = [5, 9, 13, 17];
      const thumbTip = 4;
      const thumbBase = 2;

      let extendedFingers = [];
      let extendedCount = 0;

      // æ£€æµ‹æ¯ä¸ªæ‰‹æŒ‡æ˜¯å¦ä¼¸å±•ï¼ˆæŒ‡å°– y æ¯”æŒ‡æ ¹ y æ›´å°ï¼‰
      for (let i = 0; i < fingerTips.length; i++) {
        const isExtended = landmarks[fingerTips[i]].y < landmarks[fingerBases[i]].y;
        extendedFingers.push(isExtended);
        if (isExtended) extendedCount++;
      }

      // æ£€æµ‹æ‹‡æŒ‡æ˜¯å¦å¼ å¼€ï¼ˆx è·ç¦»ï¼‰
      const thumbExtended =
        Math.abs(landmarks[thumbTip].x - landmarks[thumbBase].x) > 0.05;

      // æåˆæ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»ï¼‰
      const thumbIndexDist = Math.sqrt(
        Math.pow(landmarks[thumbTip].x - landmarks[8].x, 2) +
          Math.pow(landmarks[thumbTip].y - landmarks[8].y, 2)
      );

      // OKæ‰‹åŠ¿æ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼Œå…¶ä»–æ‰‹æŒ‡æ”¶èµ·ï¼‰
      const thumbMiddleDist = Math.sqrt(
        Math.pow(landmarks[thumbTip].x - landmarks[12].x, 2) +
          Math.pow(landmarks[thumbTip].y - landmarks[12].y, 2)
      );
      const isOK = thumbIndexDist < 0.08 && 
                   thumbMiddleDist < 0.08 && 
                   !extendedFingers[2] && 
                   !extendedFingers[3];

      // åœ°çƒæ‰‹åŠ¿æ£€æµ‹ï¼ˆæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼ŒåŒæ—¶ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡éƒ½å¼ å¼€ï¼‰
      const isSphere = thumbIndexDist < 0.08 && 
                       thumbMiddleDist < 0.08 && 
                       extendedFingers[1] &&  // ä¸­æŒ‡å¼ å¼€
                       extendedFingers[2] &&   // æ— åæŒ‡å¼ å¼€
                       extendedFingers[3];     // å°æŒ‡å¼ å¼€

      // èƒœåˆ©æ‰‹åŠ¿æ£€æµ‹ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡ä¼¸å‡ºï¼Œå…¶ä»–æ”¶èµ·ï¼‰
      const isVictory = extendedFingers[0] && 
                        extendedFingers[1] && 
                        !extendedFingers[2] && 
                        !extendedFingers[3] &&
                        !thumbExtended;

      // æ¯” 1 æ‰‹åŠ¿æ£€æµ‹ï¼ˆåªä¼¸å‡ºé£ŸæŒ‡ï¼Œå…¶å®ƒæ‰‹æŒ‡æ”¶èµ·ï¼‰
      // å®¹å¿æ‹‡æŒ‡ä½ç½®ï¼Œä¸å¼ºåˆ¶è¦æ±‚æ‹‡æŒ‡å®Œå…¨æ”¶èµ·ï¼Œé¿å…è¿‡äºä¸¥æ ¼å¯¼è‡´è¯†åˆ«ä¸åˆ°
      const isOne = extendedFingers[0] && 
                    !extendedFingers[1] && 
                    !extendedFingers[2] && 
                    !extendedFingers[3];

      if (isOne) {
        return 'one';
      } else if (isSphere) {
        return 'sphere';
      } else if (isOK) {
        return 'ok';
      } else if (isVictory) {
        return 'victory';
      } else if (thumbIndexDist < 0.05) {
        // æåˆä¹Ÿè§†ä½œåœ°çƒæ‰‹åŠ¿ï¼Œå–æ¶ˆåŸæœ¬çš„â€œèšæ‹¢ç²’å­â€åŠŸèƒ½
        return 'sphere';
      } else if (extendedCount >= 4 && thumbExtended) {
        return 'open';
      } else if (extendedCount === 1 && landmarks[8].y < landmarks[5].y) {
        return 'pointing';
      } else if (extendedCount <= 1) {
        return 'closed';
      }

      return 'neutral';
    }

    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    hands.onResults((results) => {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const gesture = detectGesture(landmarks);
        const palm = landmarks[9];

        // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨é€Ÿåº¦
        if (previousPalmX !== 0 && previousPalmY !== 0) {
          const dx = (palm.x - previousPalmX) * canvas.width;
          const dy = (palm.y - previousPalmY) * canvas.height;
          handSpeed = Math.min(1, Math.sqrt(dx * dx + dy * dy) / 100);
        }
        previousPalmX = palm.x;
        previousPalmY = palm.y;

        // æ£€æµ‹æ‰‹åŠ¿åˆ‡æ¢ï¼Œè§¦å‘çˆ†ç‚¸æ•ˆæœ
        if (previousHandData && previousHandData.gesture !== gesture) {
          if (gesture === 'victory' || gesture === 'closed') {
            const px = palm.x * canvas.width;
            const py = palm.y * canvas.height;
            const colors = {
              victory: 'rgba(255, 200, 0, 0.8)',
              closed: 'rgba(255, 100, 100, 0.8)',
            };
            explosions.push(new Explosion(px, py, colors[gesture] || 'rgba(255, 255, 255, 0.8)'));
          }
          
          // ä»æ¯” 1 æ‰‹åŠ¿åˆ‡æ¢åˆ°å…¶ä»–æ‰‹åŠ¿æ—¶ï¼Œæ¸…é™¤æ–‡å­—ç›®æ ‡
          if (previousHandData.gesture === 'one' && gesture !== 'one') {
            isFormingText = false;
            particles.forEach(p => {
              p.targetX = null;
              p.targetY = null;
            });
          }
        }

        // è®¡ç®—æ˜¯å¦è§¦å‘çƒä½“æ¨¡å¼ï¼ˆå•æ‰‹æ‰‹åŠ¿ï¼šæ‹‡æŒ‡å’Œé£ŸæŒ‡å½¢æˆåœ†åœˆï¼Œå…¶ä»–ä¸‰æŒ‡å¼ å¼€ï¼‰
        const sphereNow = gesture === 'sphere';

        // æ¨¡å¼åˆ‡æ¢ï¼šè¿›å…¥æˆ–é€€å‡ºçƒä½“æ¨¡å¼
        if (sphereNow && !isSphereMode) {
          isSphereMode = true;
          isFormingText = false;
          textTargets = [];
          // ä¸ºæ¯ä¸ªç²’å­åˆ†é…çƒé¢åæ ‡ï¼ˆå‡åŒ€åˆ†å¸ƒï¼‰
          const N = particles.length;
          const goldenAngle = Math.PI * (3 - Math.sqrt(5));
          particles.forEach((p, i) => {
            const t = N > 1 ? i / (N - 1) : 0.5;
            const y = 1 - 2 * t; // -1..1
            const r = Math.sqrt(1 - y * y);
            const theta = goldenAngle * i;
            p.sphereLat = Math.asin(y);
            p.sphereLon = theta;
            p.targetX = null;
            p.targetY = null;
          });
        } else if (!sphereNow && isSphereMode) {
          isSphereMode = false;
          // é€€å‡ºçƒä½“æ¨¡å¼ï¼Œæ¸…é™¤çƒä½“åæ ‡
          particles.forEach((p) => {
            p.sphereLat = null;
            p.sphereLon = null;
          });
        }

        // æ£€æµ‹åˆ°æ¯” 1 æ‰‹åŠ¿æ—¶ï¼Œç”Ÿæˆæ–‡å­—ç²’å­ä½ç½®ï¼ˆéçƒä½“æ¨¡å¼ä¸‹æ‰ç”Ÿæ•ˆï¼‰
        if (!isSphereMode && gesture === 'one') {
          if (!isFormingText || textTargets.length === 0) {
            isFormingText = true;
            // æ ¹æ®å½“å‰ç”»å¸ƒå¤§å°è‡ªé€‚åº”å­—å·ï¼Œç”Ÿæˆâ€œå­™åŠ æ¬£â€æ–‡å­—ç‚¹é˜µ
            textTargets = generateTextParticles('å­™åŠ æ¬£');

            // åªç”¨ä¸€éƒ¨åˆ†ç²’å­æ‹¼å­—ï¼šé€‰æ‹©é è¿‘å±å¹•ä¸­å¿ƒçš„ç²’å­
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // å¤åˆ¶ä¸€ä»½å¸¦è·ç¦»ä¿¡æ¯çš„ç²’å­æ•°ç»„
            const particlesWithDist = particles.map((p, idx) => {
              const dx = p.x - centerX;
              const dy = p.y - centerY;
              return { p, idx, dist: Math.sqrt(dx * dx + dy * dy) };
            });

            // æŒ‰è·ç¦»ä»è¿‘åˆ°è¿œæ’åº
            particlesWithDist.sort((a, b) => a.dist - b.dist);

            // å‚ä¸æ‹¼å­—çš„ç²’å­æ•°é‡ï¼ˆä¸è¶…è¿‡æ–‡å­—ç‚¹æ•°çš„ 60%ï¼Œä¹Ÿä¸è¶…è¿‡æ€»ç²’å­çš„ 60%ï¼‰
            const maxTextParticles = Math.min(
              Math.floor(particles.length * 0.6),
              Math.floor(textTargets.length * 0.6)
            );

            // å…ˆæ¸…ç©ºæ‰€æœ‰ç²’å­çš„ target
            particles.forEach((particle) => {
              particle.targetX = null;
              particle.targetY = null;
            });

            // è®©è·ç¦»ä¸­å¿ƒæœ€è¿‘çš„ä¸€éƒ¨åˆ†ç²’å­å‚ä¸æ‹¼å­—
            for (let i = 0; i < maxTextParticles; i++) {
              const { p } = particlesWithDist[i];
              const targetIndex = Math.floor(
                (i / Math.max(1, maxTextParticles - 1)) * (textTargets.length - 1)
              );
              p.targetX = textTargets[targetIndex].x;
              p.targetY = textTargets[targetIndex].y;
            }
          }
        }

        previousHandData = { gesture, palmX: palm.x, palmY: palm.y };

        handData = {
          palmX: palm.x,
          palmY: palm.y,
          gesture,
          landmarks,
        };

        const gestureNames = {
          open: 'âœ‹ å¼ å¼€æ‰‹æŒ',
          closed: 'âœŠ æ¡æ‹³',
          pointing: 'â˜ï¸ é£ŸæŒ‡',
          pinch: 'ğŸ¤ æåˆ',
          victory: 'âœŒï¸ èƒœåˆ©æ‰‹åŠ¿',
          ok: 'ğŸ‘Œ OKæ‰‹åŠ¿',
          one: 'â˜ï¸ æ¯” 1 æ‰‹åŠ¿',
          sphere: 'ğŸŒ åœ°çƒæ‰‹åŠ¿',
          neutral: 'ğŸ–ï¸ è‡ªç„¶',
        };

        statusDiv.className = 'status ready';
        if (isSphereMode) {
          statusDiv.textContent = 'æ‰‹åŠ¿: ğŸ”„ åŒæ‰‹äº¤å‰ - æ˜Ÿçƒæ¨¡å¼';
        } else {
          statusDiv.textContent = `æ‰‹åŠ¿: ${
            gestureNames[gesture] || gesture
          }`;
        }

        // æ›´æ–°é€Ÿåº¦æŒ‡ç¤ºå™¨
        const speedIndicator = document.getElementById('speedIndicator');
        const speedValue = document.getElementById('speedValue');
        if (speedIndicator && speedValue) {
          speedIndicator.style.display = 'block';
          speedValue.textContent = (handSpeed * 100).toFixed(0) + '%';
          speedValue.style.color = handSpeed > 0.5 ? '#ff6b6b' : handSpeed > 0.3 ? '#ffd93d' : '#6bcf7f';
        }
      } else {
        handData = null;
        previousHandData = null;
        handSpeed = 0;
        statusDiv.className = 'status waiting';
        statusDiv.textContent = 'ç­‰å¾…æ£€æµ‹æ‰‹åŠ¿...';
        
        // æ¸…é™¤æ–‡å­—å½¢æˆçŠ¶æ€
        if (isFormingText) {
          isFormingText = false;
          particles.forEach(p => {
            p.targetX = null;
            p.targetY = null;
          });
        }
        
        const speedIndicator = document.getElementById('speedIndicator');
        if (speedIndicator) {
          speedIndicator.style.display = 'none';
        }
      }
    });

    // å¯åŠ¨æ‘„åƒå¤´
    const camera = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480,
    });

    camera.start();

    // åŠ¨ç”»å¾ªç¯
    function animate() {
      // æ›´æ–°å½©è™¹æ¨¡å¼
      if (rainbowMode) {
        rainbowHue = (rainbowHue + 1) % 360;
      }

      // èƒŒæ™¯æ‹–å½±
      ctx.fillStyle = 'rgba(10, 10, 30, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // æ›´æ–°å’Œç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
      explosions = explosions.filter((explosion) => {
        explosion.update();
        explosion.draw();
        return explosion.particles.length > 0;
      });

      // çƒä½“æ¨¡å¼ä¸‹ï¼Œæ•´ä½“æ—‹è½¬
      if (isSphereMode) {
        sphereRotation += 0.01;
      }

      // ç»˜åˆ¶æ‰‹æŒèŒƒå›´ä¸éª¨æ¶ï¼ˆéçƒä½“æ¨¡å¼ä¸‹å±•ç¤ºï¼‰
      if (handData && !isSphereMode) {
        const px = handData.palmX * canvas.width;
        const py = handData.palmY * canvas.height;
        const radius = 400 + handSpeed * 80;

        // ç»˜åˆ¶å½±å“èŒƒå›´
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);

        const colors = {
          open: 'rgba(150, 100, 255, 0.2)',
          closed: 'rgba(255, 100, 100, 0.2)',
          pointing: 'rgba(255, 150, 50, 0.2)',
          pinch: 'rgba(100, 255, 150, 0.2)',
          victory: 'rgba(255, 200, 0, 0.3)',
          ok: 'rgba(100, 200, 255, 0.2)',
          one: 'rgba(255, 100, 150, 0.3)',
          sphere: 'rgba(100, 200, 255, 0.4)',
        };

        ctx.strokeStyle =
          colors[handData.gesture] || 'rgba(100, 100, 255, 0.2)';
        ctx.lineWidth = 2 + handSpeed * 2;
        ctx.stroke();

        // ç»˜åˆ¶èƒ½é‡æ³¢ï¼ˆå¿«é€Ÿç§»åŠ¨æ—¶ï¼‰
        if (handSpeed > 0.3) {
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(px, py, radius + i * 30, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 - i * 0.1})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }

        // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶ï¼ˆæ ¹æ®æ‰‹åŠ¿æ”¹å˜é¢œè‰²ï¼‰
        const skeletonColors = {
          open: 'rgba(150, 100, 255, 0.8)',
          closed: 'rgba(255, 100, 100, 0.8)',
          pointing: 'rgba(255, 150, 50, 0.8)',
          pinch: 'rgba(100, 255, 150, 0.8)',
          victory: 'rgba(255, 200, 0, 0.9)',
          ok: 'rgba(100, 200, 255, 0.8)',
          one: 'rgba(255, 100, 150, 0.9)',
          sphere: 'rgba(100, 200, 255, 0.9)',
        };
        ctx.strokeStyle = skeletonColors[handData.gesture] || 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2 + handSpeed;

        const connections = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 4],
          [0, 5],
          [5, 6],
          [6, 7],
          [7, 8],
          [5, 9],
          [9, 10],
          [10, 11],
          [11, 12],
          [9, 13],
          [13, 14],
          [14, 15],
          [15, 16],
          [13, 17],
          [17, 18],
          [18, 19],
          [19, 20],
          [0, 17],
        ];

        connections.forEach(([start, end]) => {
          const startPoint = handData.landmarks[start];
          const endPoint = handData.landmarks[end];
          ctx.beginPath();
          ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
          ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
          ctx.stroke();
        });

        // èƒœåˆ©æ‰‹åŠ¿ç‰¹æ®Šæ•ˆæœï¼šåœ¨æ‰‹æŒ‡å‘¨å›´ç»˜åˆ¶å…‰ç¯
        if (handData.gesture === 'victory' && handData.landmarks) {
          const indexTip = handData.landmarks[8];
          const middleTip = handData.landmarks[12];
          
          [indexTip, middleTip].forEach((tip) => {
            const tipX = tip.x * canvas.width;
            const tipY = tip.y * canvas.height;
            
            // ç»˜åˆ¶å¤šå±‚å…‰ç¯
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.arc(tipX, tipY, 15 + i * 10, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 - i * 0.15})`;
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        }

        // OKæ‰‹åŠ¿ç‰¹æ®Šæ•ˆæœï¼šåœ¨æ‹‡æŒ‡å’Œé£ŸæŒ‡ä¹‹é—´ç»˜åˆ¶è¿æ¥çº¿
        if (handData.gesture === 'ok' && handData.landmarks) {
          const thumbTip = handData.landmarks[4];
          const indexTip = handData.landmarks[8];
          
          ctx.beginPath();
          ctx.moveTo(thumbTip.x * canvas.width, thumbTip.y * canvas.height);
          ctx.lineTo(indexTip.x * canvas.width, indexTip.y * canvas.height);
          ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // åœ¨è¿æ¥ç‚¹ç»˜åˆ¶å…‰ç‚¹
          const midX = (thumbTip.x + indexTip.x) / 2 * canvas.width;
          const midY = (thumbTip.y + indexTip.y) / 2 * canvas.height;
          ctx.beginPath();
          ctx.arc(midX, midY, 8, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
          ctx.fill();
        }
      }

      // æ›´æ–°å’Œç»˜åˆ¶ç²’å­
      particles.forEach((particle) => {
        particle.update(handData);
        particle.draw();
      });

      // ç²’å­ä¹‹é—´çš„è¿çº¿ï¼ˆæ§åˆ¶æ•°é‡ï¼Œå‡è½»æ€§èƒ½å‹åŠ›ï¼‰
      particles.forEach((p1, i) => {
        // åªå¯¹å‰ä¸€éƒ¨åˆ†ç²’å­ç”»è¿çº¿ï¼Œé¿å… O(N^2) å¼€é”€
        if (i > 300) return;
        particles.slice(i + 1, i + 4).forEach((p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 80) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            
            // æ ¹æ®æ‰‹åŠ¿å’Œå½©è™¹æ¨¡å¼æ”¹å˜è¿çº¿é¢œè‰²
            let hue = 200;
            if (handData && rainbowMode) {
              hue = (rainbowHue + dist * 2) % 360;
            } else if (handData) {
              const gestureHues = {
                open: 280,
                closed: 0,
                pointing: 30,
                pinch: 120,
                victory: 60,
                ok: 200,
              };
              hue = gestureHues[handData.gesture] || 200;
            }
            
            ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${
              (1 - dist / 100) * 0.4
            })`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
        });
      });

      requestAnimationFrame(animate);
    }

    animate();

    // æ§åˆ¶é¢æ¿äº‹ä»¶
    document
      .getElementById('particleCount')
      .addEventListener('input', (e) => {
        particleCount = parseInt(e.target.value, 10);
        document.getElementById('particleCountValue').textContent =
          particleCount;
        initParticles();
      });

    document.getElementById('force').addEventListener('input', (e) => {
      forceMultiplier = parseFloat(e.target.value);
      document.getElementById('forceValue').textContent =
        forceMultiplier.toFixed(1);
    });

    document.getElementById('trailMode').addEventListener('change', (e) => {
      trailMode = e.target.checked;
    });

    document.getElementById('rainbowMode').addEventListener('change', (e) => {
      rainbowMode = e.target.checked;
    });

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      initParticles();
    });
  </script>
</body>
</html>


